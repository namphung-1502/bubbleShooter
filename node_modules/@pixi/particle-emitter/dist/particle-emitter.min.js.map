{"version":3,"sources":["../src/PropertyNode.ts","../src/ParticleUtils.ts","../src/behaviors/Behaviors.ts","../src/Particle.ts","../src/Emitter.ts","../src/behaviors/shapes/Rectangle.ts","../src/behaviors/shapes/Torus.ts","../src/behaviors/shapes/PolygonalChain.ts","../src/behaviors/AccelerationMovement.ts","../src/PropertyList.ts","../src/behaviors/Alpha.ts","../src/behaviors/AnimatedTexture.ts","../src/behaviors/BlendMode.ts","../src/behaviors/BurstSpawn.ts","../src/behaviors/Color.ts","../src/behaviors/OrderedTexture.ts","../src/behaviors/PathMovement.ts","../src/behaviors/PointSpawn.ts","../src/behaviors/RandomTexture.ts","../src/behaviors/Rotation.ts","../src/behaviors/Scale.ts","../src/behaviors/ShapeSpawn.ts","../src/behaviors/SingleTexture.ts","../src/behaviors/SpeedMovement.ts","../src/index.ts","../src/LinkedListContainer.ts","../src/EmitterConfig.ts"],"names":["PropertyNode","[object Object]","value","time","ease","this","next","isStepped","generateEase","data","array","list","node","first","hexToRGB","length","i","start","end","GetTextureFromString","Texture","from","verbose","DEG_TO_RADS","Math","PI","rotatePoint","angle","p","s","sin","c","cos","xnew","x","y","ynew","combineRGBComponents","r","g","b","point","sqrt","normalize","oneOverLen","scaleBy","color","output","alpha","charAt","substr","indexOf","parseInt","a","segments","qty","oneOverQty","t","cp","e","getBlendMode","name","toUpperCase","replace","BLEND_MODES","NORMAL","BehaviorOrder","numSteps","currentNode","current","nextIndex","lerp","curVal","nextVal","Particle","Sprite","emitter","super","prevChild","nextChild","config","anchor","maxLife","age","agePercent","oneOverLife","prev","init","kill","rotation","position","scale","tint","visible","recycle","parent","removeChild","destroy","ticker","Ticker","shared","PositionParticle","Symbol","Emitter","particleParent","initBehaviors","updateBehaviors","recycleBehaviors","minLifetime","maxLifetime","customEase","_frequency","spawnChance","maxParticles","emitterLifetime","spawnPos","Point","particlesPerWave","ownerPos","_prevEmitterPos","_prevPosIsValid","_posChanged","_parent","addAtBack","particleCount","_emit","_spawnTimer","_emitterLife","_activeParticlesFirst","_activeParticlesLast","_poolFirst","_origConfig","_autoUpdate","_destroyWhenComplete","_completeCallback","update","rotate","updateSpawnPos","updateOwnerPos","constructor","knownBehaviors","type","frequency","cleanup","lifetime","min","max","set","pos","copyFrom","emit","undefined","autoUpdate","behaviors","map","console","error","filter","push","sort","order","Spawn","slice","updateParticle","recycleParticle","find","count","particle","fromCleanup","newRot","diff","remove","add","callback","delta","settings","TARGET_FPMS","prevX","prevY","curX","curY","emitPosX","emitPosY","waveFirst","waveLast","len","random","addChildAt","addChild","behavior","initParticles","cb","destroyed","Rectangle","w","h","editorConfig","Torus","radius","innerRadius","affectRotation","PolygonalChain","countingLengths","totalLength","Array","isArray","chain","prevPoint","j","second","p1","p2","l","segLength","out","rand","chosenSeg","AccelerationBehavior","Late","minStart","maxStart","accel","maxSpeed","_a","speed","velocity","deltaSec","vel","oldVX","oldVY","currentSpeed","atan2","intValueSimple","intColorSimple","intValueComplex","intColorComplex","intValueStepped","intColorStepped","PropertyList","isColor","interpolate","AlphaBehavior","Normal","reset","createList","StaticAlphaBehavior","getTextures","textures","outTextures","tex","dupe","texture","RandomAnimatedTextureBehavior","anims","anim","framerate","parsedAnim","duration","loop","index","floor","animElapsed","animDuration","animFramerate","frame","EMPTY","SingleAnimatedTextureBehavior","BlendModeBehavior","blendMode","BurstSpawnBehavior","spacing","distance","ColorBehavior","StaticColorBehavior","OrderedTextureBehavior","helperPoint","MATH_FUNCS","WHITELISTER","RegExp","concat","join","PathBehavior","path","pathString","matches","match","Function","parsePath","minMult","initRotation","initPosition","movement","mult","speedMult","PointSpawnBehavior","_first","RandomTextureBehavior","RotationBehavior","minSpeed","rotSpeed","oldSpeed","StaticRotationBehavior","NoRotationBehavior","ScaleBehavior","scaleMult","StaticScaleBehavior","ShapeSpawnBehavior","ShapeClass","shapes","Error","shape","typeOverride","getRandPos","registerShape","SingleTextureBehavior","SpeedBehavior","StaticSpeedBehavior","registerBehavior","behaviors.AccelerationBehavior","behaviors.AlphaBehavior","behaviors.StaticAlphaBehavior","behaviors.RandomAnimatedTextureBehavior","behaviors.SingleAnimatedTextureBehavior","behaviors.BlendModeBehavior","behaviors.BurstSpawnBehavior","behaviors.ColorBehavior","behaviors.StaticColorBehavior","behaviors.OrderedTextureBehavior","behaviors.PathBehavior","behaviors.PointSpawnBehavior","behaviors.RandomTextureBehavior","behaviors.RotationBehavior","behaviors.StaticRotationBehavior","behaviors.NoRotationBehavior","behaviors.ScaleBehavior","behaviors.StaticScaleBehavior","behaviors.ShapeSpawnBehavior","behaviors.SingleTextureBehavior","behaviors.SpeedBehavior","behaviors.StaticSpeedBehavior","Container","_firstChild","_lastChild","_childCount","firstChild","lastChild","childCount","children","child","sortDirty","transform","_parentID","_boundsID","onChildrenChange","target","relative","child2","test","getChildAt","beginIndex","endIndex","begin","range","removed","RangeError","updateTransform","worldAlpha","_bounds","clear","_calculateBounds","renderable","calculateBounds","_mask","maskObject","addBoundsMask","filterArea","addBoundsArea","addBounds","updateID","rect","skipChildrenUpdate","result","DisplayObject","prototype","getLocalBounds","call","renderer","filters","renderAdvanced","_render","render","batch","flush","mask","_enabledFilters","enabled","pop","maskManager","pushMask","_renderCanvas","renderCanvas","popMask","art","acceleration","minimumSpeedMultiplier","_b","noRotation","_c","extraData","_d","_e","_f","_g","_h","_j","minimumScaleMultiplier","_k","_l","rotationAcceleration","_m","rotationSpeed","_o","_p","_q","startRotation","_r","_s","_t","_u","_v","orderedArt","spawnType","angleStart","particleSpacing","spawnCircle","minR","spawnRect","spawnPolygon"],"mappings":"qEAuCaA,EAyBTC,YAAYC,EAAUC,EAAcC,GAEhCC,KAAKH,MAAQA,EACbG,KAAKF,KAAOA,EACZE,KAAKC,KAAO,KACZD,KAAKE,WAAY,EAGbF,KAAKD,KAFLA,EAE4B,mBAATA,EAAsBA,EAAOI,EAAaJ,GAIjD,KAebH,kBAA4CQ,GAE/C,GAAI,SAAUA,EACd,CACI,MAAMC,EAAQD,EAAKE,KACnB,IAAIC,EACJ,MAAMV,MAAEA,EAAKC,KAAEA,GAASO,EAAM,GAGxBG,EAAQD,EAAO,IAAIZ,EAA8B,iBAAVE,EAAqBY,EAASZ,GAASA,EAAOC,EAAMM,EAAKL,MAGtG,GAAIM,EAAMK,OAAS,GAAuB,IAAjBL,EAAMK,QAAgBL,EAAM,GAAGR,QAAUA,EAE9D,IAAK,IAAIc,EAAI,EAAGA,EAAIN,EAAMK,SAAUC,EACpC,CACI,MAAMd,MAAEA,EAAKC,KAAEA,GAASO,EAAMM,GAE9BJ,EAAKN,KAAO,IAAIN,EAA8B,iBAAVE,EAAqBY,EAASZ,GAASA,EAAOC,GAClFS,EAAOA,EAAKN,KAKpB,OAFAO,EAAMN,YAAcE,EAAKF,UAElBM,EAIX,MAAMI,EAAQ,IAAIjB,EAAmC,iBAAfS,EAAKQ,MAAqBH,EAASL,EAAKQ,OAASR,EAAKQ,MAAO,GAQnG,OALIR,EAAKS,MAAQT,EAAKQ,QAElBA,EAAMX,KAAO,IAAIN,EAAiC,iBAAbS,EAAKS,IAAmBJ,EAASL,EAAKS,KAAOT,EAAKS,IAAK,IAGzFD,GCrHR,IAAIE,EAA6CC,EAAAA,QAAQC,KA2BzD,MAAMC,GAAU,EAEVC,EAAcC,KAAKC,GAAK,aAOrBC,EAAYC,EAAeC,GAEvC,IAAKD,EAAO,OAEZ,MAAME,EAAIL,KAAKM,IAAIH,GACbI,EAAIP,KAAKQ,IAAIL,GACbM,EAAQL,EAAEM,EAAIH,EAAMH,EAAEO,EAAIN,EAC1BO,EAAQR,EAAEM,EAAIL,EAAMD,EAAEO,EAAIJ,EAEhCH,EAAEM,EAAID,EACNL,EAAEO,EAAIC,WAUMC,EAAqBC,EAAWC,EAAWC,GAEvD,OAAuBF,GAAK,GAAOC,GAAK,EAAKC,WAQjCzB,EAAO0B,GAEnB,OAAOjB,KAAKkB,KAAMD,EAAMP,EAAIO,EAAMP,EAAMO,EAAMN,EAAIM,EAAMN,YAO5CQ,EAAUF,GAEtB,MAAMG,EAAa,EAAI7B,EAAO0B,GAE9BA,EAAMP,GAAKU,EACXH,EAAMN,GAAKS,WAQCC,EAAQJ,EAAmBvC,GAEvCuC,EAAMP,GAAKhC,EACXuC,EAAMN,GAAKjC,WAWCY,EAASgC,EAAeC,GAcpC,IAAIC,EAeJ,OA3BKD,IAEDA,EAAS,IAEW,MAApBD,EAAMG,OAAO,GAEbH,EAAQA,EAAMI,OAAO,GAEQ,IAAxBJ,EAAMK,QAAQ,QAEnBL,EAAQA,EAAMI,OAAO,IAIJ,IAAjBJ,EAAM/B,SAENiC,EAAQF,EAAMI,OAAO,EAAG,GACxBJ,EAAQA,EAAMI,OAAO,IAEzBH,EAAOT,EAAIc,SAASN,EAAMI,OAAO,EAAG,GAAI,IACxCH,EAAOR,EAAIa,SAASN,EAAMI,OAAO,EAAG,GAAI,IACxCH,EAAOP,EAAIY,SAASN,EAAMI,OAAO,EAAG,GAAI,IACpCF,IAEAD,EAAOM,EAAID,SAASJ,EAAO,KAGxBD,WAWKvC,EAAa8C,GAEzB,MAAMC,EAAMD,EAASvC,OACfyC,EAAa,EAAID,EASvB,OAAO,SAAUpD,GAEb,MAAMa,EAAKuC,EAAMpD,EAAQ,EAEnBsD,GAAKtD,EAAQa,EAAIwC,GAAeD,EAChC1B,EAAIyB,EAAStC,IAAMsC,EAASC,EAAM,GAExC,OAAQ1B,EAAEA,EAAK4B,GAAM,GAAK,EAAIA,IAAM5B,EAAE6B,GAAK7B,EAAEA,GAAO4B,GAAK5B,EAAE8B,EAAI9B,EAAEA,cASzD+B,EAAaC,GAEzB,OAAKA,GACLA,EAAOA,EAAKC,cAAcC,QAAQ,KAAM,KAEhCC,EAAAA,YAAoBH,IAASG,EAAAA,YAAYC,QAH/BD,EAAAA,YAAYC,WC1HtBC,+MDwI0BvD,EAA2BwD,EAAW,KAEhD,iBAAbA,GAAyBA,GAAY,KAE5CA,EAAW,IAEf,MAAMtD,EAAQ,IAAIb,EAAoBc,EAASH,EAAK,GAAGT,OAAQS,EAAK,GAAGR,MAEvEU,EAAMN,WAAY,EAClB,IAAI6D,EAAcvD,EACdwD,EAAU1D,EAAK,GACf2D,EAAY,EACZhE,EAAOK,EAAK2D,GAEhB,IAAK,IAAItD,EAAI,EAAGA,EAAImD,IAAYnD,EAChC,CACI,IAAIuD,EAAOvD,EAAImD,EAGf,KAAOI,EAAOjE,EAAKH,MAEfkE,EAAU/D,EACVA,EAAOK,IAAO2D,GAGlBC,GAAQA,EAAOF,EAAQlE,OAASG,EAAKH,KAAOkE,EAAQlE,MACpD,MAAMqE,EAAS1D,EAASuD,EAAQnE,OAC1BuE,EAAU3D,EAASR,EAAKJ,OACxB6C,EAAgB,CAClBT,GAAKmC,EAAQnC,EAAIkC,EAAOlC,GAAKiC,EAAQC,EAAOlC,EAC5CC,GAAKkC,EAAQlC,EAAIiC,EAAOjC,GAAKgC,EAAQC,EAAOjC,EAC5CC,GAAKiC,EAAQjC,EAAIgC,EAAOhC,GAAK+B,EAAQC,EAAOhC,GAGhD4B,EAAY9D,KAAO,IAAIN,EAAa+C,EAAQ/B,EAAImD,GAChDC,EAAcA,EAAY9D,KAK9B,OAAOO,UErOE6D,UAAiBC,EAAAA,OA2C1B1E,YAAY2E,GAIRC,QAEAxE,KAAKyE,UAAYzE,KAAK0E,UAAY,KAElC1E,KAAKuE,QAAUA,EACfvE,KAAK2E,OAAS,GAEd3E,KAAK4E,OAAO/C,EAAI7B,KAAK4E,OAAO9C,EAAI,GAChC9B,KAAK6E,QAAU,EACf7E,KAAK8E,IAAM,EACX9E,KAAK+E,WAAa,EAClB/E,KAAKgF,YAAc,EACnBhF,KAAKC,KAAO,KACZD,KAAKiF,KAAO,KAGZjF,KAAKkF,KAAOlF,KAAKkF,KACjBlF,KAAKmF,KAAOnF,KAAKmF,KAOdvF,KAAKiF,GAER7E,KAAK6E,QAAUA,EAEf7E,KAAK8E,IAAM9E,KAAK+E,WAAa,EAE7B/E,KAAKoF,SAAW,EAChBpF,KAAKqF,SAASxD,EAAI7B,KAAKqF,SAASvD,EAAI,EACpC9B,KAAKsF,MAAMzD,EAAI7B,KAAKsF,MAAMxD,EAAI,EAC9B9B,KAAKuF,KAAO,SACZvF,KAAK2C,MAAQ,EAEb3C,KAAKgF,YAAc,EAAIhF,KAAK6E,QAG5B7E,KAAKwF,SAAU,EAOZ5F,OAEHI,KAAKuE,QAAQkB,QAAQzF,MAMlBJ,UAECI,KAAK0F,QAEL1F,KAAK0F,OAAOC,YAAY3F,MAE5BA,KAAKuE,QAAUvE,KAAKC,KAAOD,KAAKiF,KAAO,KACvCT,MAAMoB,YDvDd,SAAY/B,GAMRA,EAAAA,EAAA,MAAA,GAAA,QAIAA,EAAAA,EAAA,OAAA,GAAA,SAIAA,EAAAA,EAAA,KAAA,GAAA,OAdJ,CAAYA,IAAAA,EAAa,KEhDzB,MAAMgC,EAASC,EAAAA,OAAOC,OAMhBC,EAAmBC,OAAO,gDAKnBC,EA2KTtG,YAAYuG,EAA2BxB,GAEnC3E,KAAKoG,cAAgB,GACrBpG,KAAKqG,gBAAkB,GACvBrG,KAAKsG,iBAAmB,GAExBtG,KAAKuG,YAAc,EACnBvG,KAAKwG,YAAc,EACnBxG,KAAKyG,WAAa,KAElBzG,KAAK0G,WAAa,EAClB1G,KAAK2G,YAAc,EACnB3G,KAAK4G,aAAe,IACpB5G,KAAK6G,iBAAmB,EACxB7G,KAAK8G,SAAW,IAAIC,EAAAA,MACpB/G,KAAKgH,iBAAmB,EAExBhH,KAAKoF,SAAW,EAChBpF,KAAKiH,SAAW,IAAIF,EAAAA,MACpB/G,KAAKkH,gBAAkB,IAAIH,EAAAA,MAC3B/G,KAAKmH,iBAAkB,EACvBnH,KAAKoH,aAAc,EACnBpH,KAAKqH,QAAU,KACfrH,KAAKsH,WAAY,EACjBtH,KAAKuH,cAAgB,EACrBvH,KAAKwH,OAAQ,EACbxH,KAAKyH,YAAc,EACnBzH,KAAK0H,cAAgB,EACrB1H,KAAK2H,sBAAwB,KAC7B3H,KAAK4H,qBAAuB,KAC5B5H,KAAK6H,WAAa,KAClB7H,KAAK8H,YAAc,KACnB9H,KAAK+H,aAAc,EACnB/H,KAAKgI,sBAAuB,EAC5BhI,KAAKiI,kBAAoB,KAGzBjI,KAAK0F,OAASS,EAEVxB,GAEA3E,KAAKkF,KAAKP,GAId3E,KAAKyF,QAAUzF,KAAKyF,QACpBzF,KAAKkI,OAASlI,KAAKkI,OACnBlI,KAAKmI,OAASnI,KAAKmI,OACnBnI,KAAKoI,eAAiBpI,KAAKoI,eAC3BpI,KAAKqI,eAAiBrI,KAAKqI,eAlNxBzI,wBAAwB0I,GAE3BpC,EAAQqC,eAAeD,EAAYE,MAAQF,EAuN/CG,gBAAiC,OAAOzI,KAAK0G,WAC7C+B,cAAqB5I,GAKbG,KAAK0G,WAFY,iBAAV7G,GAAsBA,EAAQ,EAEnBA,EAIA,EAO1B6F,aAAiC,OAAO1F,KAAKqH,QAC7C3B,WAAkB7F,GAEdG,KAAK0I,UACL1I,KAAKqH,QAAUxH,EAOZD,KAAK+E,GAER,IAAKA,EAED,OAGJ3E,KAAK0I,UAIL1I,KAAK8H,YAAcnD,EAOnB3E,KAAKuG,YAAc5B,EAAOgE,SAASC,IACnC5I,KAAKwG,YAAc7B,EAAOgE,SAASE,IAE/BlE,EAAO5E,KAEPC,KAAKyG,WAAoC,mBAAhB9B,EAAO5E,KAC1B4E,EAAO5E,KAAOI,EAAawE,EAAO5E,MAIxCC,KAAKyG,WAAa,KAMtBzG,KAAKgH,iBAAmB,EACpBrC,EAAOqC,kBAAoBrC,EAAOqC,iBAAmB,IAErDhH,KAAKgH,iBAAmBrC,EAAOqC,kBAGnChH,KAAKyI,UAAY9D,EAAO8D,UACxBzI,KAAK2G,YAA6C,iBAAvBhC,EAAOgC,aAA4BhC,EAAOgC,YAAc,EAAKhC,EAAOgC,YAAc,EAE7G3G,KAAK6G,gBAAkBlC,EAAOkC,kBAAoB,EAElD7G,KAAK4G,aAAejC,EAAOiC,aAAe,EAAIjC,EAAOiC,aAAe,IAEpE5G,KAAKsH,YAAc3C,EAAO2C,UAE1BtH,KAAKoF,SAAW,EAChBpF,KAAKiH,SAAS6B,IAAI,GACdnE,EAAOoE,IAEP/I,KAAK8G,SAASkC,SAASrE,EAAOoE,KAI9B/I,KAAK8G,SAASgC,IAAI,GAGtB9I,KAAKkH,gBAAgB8B,SAAShJ,KAAK8G,UAEnC9G,KAAKmH,iBAAkB,EAEvBnH,KAAKyH,YAAc,EACnBzH,KAAKiJ,UAAuBC,IAAhBvE,EAAOsE,QAA8BtE,EAAOsE,KACxDjJ,KAAKmJ,aAAexE,EAAOwE,WAK3B,MAAMC,EAA4DzE,EAAOyE,UAAUC,IAAKjJ,IAEpF,MAAMkI,EAAcpC,EAAQqC,eAAenI,EAAKoI,MAEhD,OAAKF,EAOE,IAAIA,EAAYlI,EAAKuE,SALxB2E,QAAQC,2BAA2BnJ,EAAKoI,QAEjC,QAKVgB,OAAQrH,KAAQA,GAErBiH,EAAUK,KAAKzD,GACfoD,EAAUM,KAAK,CAAC1G,EAAGb,IAEXa,IAAMgD,EAEE7D,EAAuBwH,QAAU9F,EAAc+F,MAAQ,GAAK,EAE/DzH,IAAM6D,EAEHhD,EAAuB2G,QAAU9F,EAAc+F,OAAS,EAAI,EAGhE5G,EAAuB2G,MAASxH,EAAuBwH,OAEnE3J,KAAKoG,cAAgBgD,EAAUS,QAC/B7J,KAAKqG,gBAAkB+C,EAAUI,OAAQrH,GAAMA,IAAM6D,GAAoB7D,EAAE2H,gBAC3E9J,KAAKsG,iBAAmB8C,EAAUI,OAAQrH,GAAMA,IAAM6D,GAAoB7D,EAAE4H,iBAOzEnK,YAAY4I,GAGf,OAAKtC,EAAQqC,eAAeC,IAGrBxI,KAAKoG,cAAc4D,KAAM7H,GAAMA,aAAa+D,EAAQqC,eAAeC,KAHhC,KAUvC5I,SAASqK,GAEZ,KAAOA,EAAQ,IAAKA,EACpB,CACI,MAAM1I,EAAI,IAAI8C,EAASrE,MAEvBuB,EAAEtB,KAAOD,KAAK6H,WACd7H,KAAK6H,WAAatG,GAUnB3B,QAAQsK,EAAoBC,GAAc,GAE7C,IAAK,IAAIxJ,EAAI,EAAGA,EAAIX,KAAKsG,iBAAiB5F,SAAUC,EAEhDX,KAAKsG,iBAAiB3F,GAAGoJ,gBAAgBG,GAAWC,GAEpDD,EAASjK,OAETiK,EAASjK,KAAKgF,KAAOiF,EAASjF,MAE9BiF,EAASjF,OAETiF,EAASjF,KAAKhF,KAAOiK,EAASjK,MAE9BiK,IAAalK,KAAK4H,uBAElB5H,KAAK4H,qBAAuBsC,EAASjF,MAErCiF,IAAalK,KAAK2H,wBAElB3H,KAAK2H,sBAAwBuC,EAASjK,MAG1CiK,EAASjF,KAAO,KAChBiF,EAASjK,KAAOD,KAAK6H,WACrB7H,KAAK6H,WAAaqC,EAEdA,EAASxE,QAETwE,EAASxE,OAAOC,YAAYuE,KAG9BlK,KAAKuH,cAQJ3H,OAAOwK,GAEV,GAAIpK,KAAKoF,WAAagF,EAAQ,OAE9B,MAAMC,EAAOD,EAASpK,KAAKoF,SAE3BpF,KAAKoF,SAAWgF,EAEhB/I,EAAYgJ,EAAMrK,KAAK8G,UAEvB9G,KAAKoH,aAAc,EAQhBxH,eAAeiC,EAAWC,GAE7B9B,KAAKoH,aAAc,EACnBpH,KAAK8G,SAASjF,EAAIA,EAClB7B,KAAK8G,SAAShF,EAAIA,EASflC,eAAeiC,EAAWC,GAE7B9B,KAAKoH,aAAc,EACnBpH,KAAKiH,SAASpF,EAAIA,EAClB7B,KAAKiH,SAASnF,EAAIA,EAQflC,wBAEHI,KAAKmH,iBAAkB,EAO3B8B,WAA6B,OAAOjJ,KAAKwH,MACzCyB,SAAgBpJ,GAEZG,KAAKwH,QAAU3H,EACfG,KAAK0H,aAAe1H,KAAK6G,gBAO7BsC,iBAAmC,OAAOnJ,KAAK+H,YAC/CoB,eAAsBtJ,GAEdG,KAAK+H,cAAgBlI,EAErBgG,EAAOyE,OAAOtK,KAAKkI,OAAQlI,OAErBA,KAAK+H,aAAelI,GAE1BgG,EAAO0E,IAAIvK,KAAKkI,OAAQlI,MAE5BA,KAAK+H,cAAgBlI,EAQlBD,mBAAmB4K,GAEtBxK,KAAKmJ,YAAa,EAClBnJ,KAAKiJ,MAAO,EACZjJ,KAAKgI,sBAAuB,EAC5BhI,KAAKiI,kBAAoBuC,EAOtB5K,SAAS4K,GAEZxK,KAAKiJ,MAAO,EACZjJ,KAAKiI,kBAAoBuC,EAOtB5K,OAAO6K,GASV,GAPIzK,KAAK+H,cAEL0C,EAAQA,EAAQC,EAAAA,SAASC,YAAc,MAKtC3K,KAAKqH,QAAS,OAKnB,IAAK,IAA2CpH,EAAvCiK,EAAWlK,KAAK2H,sBAA6BuC,EAAUA,EAAWjK,EAOvE,GAJAA,EAAOiK,EAASjK,KAEhBiK,EAASpF,KAAO2F,EAEZP,EAASpF,IAAMoF,EAASrF,SAAWqF,EAASpF,IAAM,EAElD9E,KAAKyF,QAAQyE,OAGjB,CAEI,IAAIhG,EAAOgG,EAASpF,IAAMoF,EAASlF,YAG/BhF,KAAKyG,aAMDvC,EAJ2B,IAA3BlE,KAAKyG,WAAW/F,OAIRV,KAAKyG,WAAmBvC,EAAM,EAAG,EAAG,GAMrClE,KAAKyG,WAAWvC,IAK/BgG,EAASnF,WAAab,EAGtB,IAAK,IAAIvD,EAAI,EAAGA,EAAIX,KAAKqG,gBAAgB3F,SAAUC,EAE/C,GAAIX,KAAKqG,gBAAgB1F,GAAGmJ,eAAeI,EAAUO,GACrD,CACIzK,KAAKyF,QAAQyE,GACb,OAMhB,IAAIU,EACAC,EAGA7K,KAAKmH,kBAELyD,EAAQ5K,KAAKkH,gBAAgBrF,EAC7BgJ,EAAQ7K,KAAKkH,gBAAgBpF,GAGjC,MAAMgJ,EAAO9K,KAAKiH,SAASpF,EAAI7B,KAAK8G,SAASjF,EACvCkJ,EAAO/K,KAAKiH,SAASnF,EAAI9B,KAAK8G,SAAShF,EAG7C,GAAI9B,KAAKwH,MAKL,IAFAxH,KAAKyH,aAAegD,EAAQ,EAAI,EAAIA,EAE7BzK,KAAKyH,aAAe,GAC3B,CAEI,GAAIzH,KAAK0H,cAAgB,IAErB1H,KAAK0H,cAAgB1H,KAAK0G,WACtB1G,KAAK0H,cAAgB,GACzB,CACI1H,KAAKyH,YAAc,EACnBzH,KAAK0H,aAAe,EACpB1H,KAAKiJ,MAAO,EACZ,MAIR,GAAIjJ,KAAKuH,eAAiBvH,KAAK4G,aAC/B,CACI5G,KAAKyH,aAAezH,KAAK0G,WACzB,SAEJ,IAAIsE,EACAC,EAIJ,GAAIjL,KAAKmH,iBAAmBnH,KAAKoH,YACjC,CAEI,MAAMlD,EAAO,EAAKlE,KAAKyH,YAAcgD,EAErCO,GAAaF,EAAOF,GAAS1G,EAAQ0G,EACrCK,GAAaF,EAAOF,GAAS3G,EAAQ2G,OAKrCG,EAAWF,EACXG,EAAWF,EAGf,IAAIG,EAAsB,KACtBC,EAAqB,KAGzB,IAAK,IAAIC,EAAMjK,KAAKyH,IAAI5I,KAAKgH,iBAAkBhH,KAAK4G,aAAe5G,KAAKuH,eAAgB5G,EAAI,EAAGA,EAAIyK,IAAOzK,EAC1G,CAEI,GAAIX,KAAK2G,YAAc,GAAKxF,KAAKkK,UAAYrL,KAAK2G,YAE9C,SAGJ,IAAIgC,EAgBApH,GAZAoH,EAFA3I,KAAKuG,cAAgBvG,KAAKwG,YAEfxG,KAAKuG,YAIJpF,KAAKkK,UAAYrL,KAAKwG,YAAcxG,KAAKuG,aAAgBvG,KAAKuG,aAGzEvG,KAAKyH,aAAekB,KAOrB3I,KAAK6H,YAELtG,EAAIvB,KAAK6H,WACT7H,KAAK6H,WAAa7H,KAAK6H,WAAW5H,KAClCsB,EAAEtB,KAAO,MAITsB,EAAI,IAAI8C,EAASrE,MAIrBuB,EAAE2D,KAAKyD,GAEH3I,KAAKsH,UAELtH,KAAKqH,QAAQiE,WAAW/J,EAAG,GAI3BvB,KAAKqH,QAAQkE,SAAShK,GAGtB2J,GAEAC,EAASlL,KAAOsB,EAChBA,EAAE0D,KAAOkG,EACTA,EAAW5J,GAIX4J,EAAWD,EAAY3J,IAGzBvB,KAAKuH,eAGX,GAAI2D,EACJ,CAEQlL,KAAK4H,sBAEL5H,KAAK4H,qBAAqB3H,KAAOiL,EACjCA,EAAUjG,KAAOjF,KAAK4H,qBACtB5H,KAAK4H,qBAAuBuD,IAI5BnL,KAAK2H,sBAAwBuD,EAC7BlL,KAAK4H,qBAAuBuD,GAGhC,IAAK,IAAIxK,EAAI,EAAGA,EAAIX,KAAKoG,cAAc1F,SAAUC,EACjD,CACI,MAAM6K,EAAWxL,KAAKoG,cAAczF,GAIpC,GAAI6K,IAAaxF,EAEb,IAAK,IAA0B/F,EAAtBiK,EAAWgB,EAAiBhB,EAAUA,EAAWjK,EAC1D,CAEIA,EAAOiK,EAASjK,KAEM,IAAlBD,KAAKoF,WAEL/D,EAAYrB,KAAKoF,SAAU8E,EAAS7E,UACpC6E,EAAS9E,UAAYpF,KAAKoF,UAG9B8E,EAAS7E,SAASxD,GAAKmJ,EACvBd,EAAS7E,SAASvD,GAAKmJ,EAGvBf,EAASpF,KAAO2F,EAEhB,IAAIvG,EAAOgG,EAASpF,IAAMoF,EAASlF,YAG/BhF,KAAKyG,aAMDvC,EAJ2B,IAA3BlE,KAAKyG,WAAW/F,OAIRV,KAAKyG,WAAmBvC,EAAM,EAAG,EAAG,GAMrClE,KAAKyG,WAAWvC,IAI/BgG,EAASnF,WAAab,OAK1BsH,EAASC,cAAcP,GAG/B,IAAK,IAA0BjL,EAAtBiK,EAAWgB,EAAiBhB,EAAUA,EAAWjK,EAC1D,CAEIA,EAAOiK,EAASjK,KAEhB,IAAK,IAAIU,EAAI,EAAGA,EAAIX,KAAKqG,gBAAgB3F,SAAUC,EAG/C,GAAIX,KAAKqG,gBAAgB1F,GAAGmJ,eAAeI,GAAWlK,KAAKyH,aAC3D,CAEIzH,KAAKyF,QAAQyE,GACb,QAMhBlK,KAAKyH,aAAezH,KAAK0G,WAajC,GATI1G,KAAKoH,cAELpH,KAAKkH,gBAAgBrF,EAAIiJ,EACzB9K,KAAKkH,gBAAgBpF,EAAIiJ,EACzB/K,KAAKmH,iBAAkB,EACvBnH,KAAKoH,aAAc,IAIlBpH,KAAKwH,QAAUxH,KAAK2H,sBACzB,CACI,GAAI3H,KAAKiI,kBACT,CACI,MAAMyD,EAAK1L,KAAKiI,kBAEhBjI,KAAKiI,kBAAoB,KACzByD,IAEA1L,KAAKgI,sBAELhI,KAAK4F,WAUVhG,UAEH,MAAMoL,EAAWhL,KAAKiH,SAASpF,EAAI7B,KAAK8G,SAASjF,EAC3CoJ,EAAWjL,KAAKiH,SAASnF,EAAI9B,KAAK8G,SAAShF,EAEjD,IAAIoJ,EAAsB,KACtBC,EAAqB,KAGzB,IAAK,IAAIC,EAAMjK,KAAKyH,IAAI5I,KAAKgH,iBAAkBhH,KAAK4G,aAAe5G,KAAKuH,eAAgB5G,EAAI,EAAGA,EAAIyK,IAAOzK,EAC1G,CAEI,GAAIX,KAAK2G,YAAc,GAAKxF,KAAKkK,UAAYrL,KAAK2G,YAE9C,SAGJ,IAAIpF,EAaAoH,EAXA3I,KAAK6H,YAELtG,EAAIvB,KAAK6H,WACT7H,KAAK6H,WAAa7H,KAAK6H,WAAW5H,KAClCsB,EAAEtB,KAAO,MAITsB,EAAI,IAAI8C,EAASrE,MAOjB2I,EAFA3I,KAAKuG,cAAgBvG,KAAKwG,YAEfxG,KAAKuG,YAIJpF,KAAKkK,UAAYrL,KAAKwG,YAAcxG,KAAKuG,aAAgBvG,KAAKuG,YAG9EhF,EAAE2D,KAAKyD,GAEH3I,KAAKsH,UAELtH,KAAKqH,QAAQiE,WAAW/J,EAAG,GAI3BvB,KAAKqH,QAAQkE,SAAShK,GAGtB2J,GAEAC,EAASlL,KAAOsB,EAChBA,EAAE0D,KAAOkG,EACTA,EAAW5J,GAIX4J,EAAWD,EAAY3J,IAGzBvB,KAAKuH,cAGX,GAAI2D,EACJ,CAEQlL,KAAK4H,sBAEL5H,KAAK4H,qBAAqB3H,KAAOiL,EACjCA,EAAUjG,KAAOjF,KAAK4H,qBACtB5H,KAAK4H,qBAAuBuD,IAI5BnL,KAAK2H,sBAAwBuD,EAC7BlL,KAAK4H,qBAAuBuD,GAGhC,IAAK,IAAIxK,EAAI,EAAGA,EAAIX,KAAKoG,cAAc1F,SAAUC,EACjD,CACI,MAAM6K,EAAWxL,KAAKoG,cAAczF,GAIpC,GAAI6K,IAAaxF,EAEb,IAAK,IAA0B/F,EAAtBiK,EAAWgB,EAAiBhB,EAAUA,EAAWjK,EAGtDA,EAAOiK,EAASjK,KAEM,IAAlBD,KAAKoF,WAEL/D,EAAYrB,KAAKoF,SAAU8E,EAAS7E,UACpC6E,EAAS9E,UAAYpF,KAAKoF,UAG9B8E,EAAS7E,SAASxD,GAAKmJ,EACvBd,EAAS7E,SAASvD,GAAKmJ,OAK3BO,EAASC,cAAcP,KAShCtL,UAEH,IAAIsK,EACAjK,EAEJ,IAAKiK,EAAWlK,KAAK2H,sBAAuBuC,EAAUA,EAAWjK,EAE7DA,EAAOiK,EAASjK,KAChBD,KAAKyF,QAAQyE,GAAU,GAE3BlK,KAAK2H,sBAAwB3H,KAAK4H,qBAAuB,KACzD5H,KAAKuH,cAAgB,EAOzBoE,gBAEI,QAAS3L,KAAKqH,SAAWrH,KAAKoG,cAAc1F,QAMzCd,UAOH,IAAIK,EAJJD,KAAKmJ,YAAa,EAElBnJ,KAAK0I,UAIL,IAAK,IAAIwB,EAAWlK,KAAK6H,WAAYqC,EAAUA,EAAWjK,EAGtDA,EAAOiK,EAASjK,KAChBiK,EAAStE,UAEb5F,KAAK6H,WAAa7H,KAAKqH,QAAUrH,KAAK8G,SAAW9G,KAAKiH,SAChDjH,KAAKyG,WAAazG,KAAKiI,kBAAoB,KAEjDjI,KAAKoG,cAAc1F,OAASV,KAAKqG,gBAAgB3F,OAASV,KAAKsG,iBAAiB5F,OAAS,GA1+B9EwF,EAAAqC,eAAyD,SCL/DqD,EAqBThM,YAAY+E,GAmBR3E,KAAK6B,EAAI8C,EAAO9C,EAChB7B,KAAK8B,EAAI6C,EAAO7C,EAChB9B,KAAK6L,EAAIlH,EAAOkH,EAChB7L,KAAK8L,EAAInH,EAAOmH,EAGpBlM,WAAWsK,GAGPA,EAASrI,EAAKV,KAAKkK,SAAWrL,KAAK6L,EAAK7L,KAAK6B,EAC7CqI,EAASpI,EAAKX,KAAKkK,SAAWrL,KAAK8L,EAAK9L,KAAK8B,GAhDnC8J,EAAApD,KAAO,OACPoD,EAAAG,aAA+B,WCApCC,EAyBTpM,YAAY+E,GAyBR3E,KAAK6B,EAAI8C,EAAO9C,GAAK,EACrB7B,KAAK8B,EAAI6C,EAAO7C,GAAK,EACrB9B,KAAKiM,OAAStH,EAAOsH,OACrBjM,KAAKkM,YAAcvH,EAAOuH,aAAe,EACzClM,KAAKoF,WAAaT,EAAOwH,eAG7BvM,WAAWsK,GAGHlK,KAAKkM,cAAgBlM,KAAKiM,OAE1B/B,EAASrI,EAAKV,KAAKkK,UAAYrL,KAAKiM,OAASjM,KAAKkM,aAAgBlM,KAAKkM,YAIvEhC,EAASrI,EAAI7B,KAAKiM,OAEtB/B,EAASpI,EAAI,EAEb,MAAMR,EAAQH,KAAKkK,SAAWlK,KAAKC,GAAK,EAEpCpB,KAAKoF,WAEL8E,EAAS9E,UAAY9D,GAEzBD,EAAYC,EAAO4I,EAAS7E,UAE5B6E,EAAS7E,SAASxD,GAAK7B,KAAK6B,EAC5BqI,EAAS7E,SAASvD,GAAK9B,KAAK8B,GA7ElBkK,EAAAxD,KAAO,QACPwD,EAAAD,aAA+B,WCApCK,EAqBTxM,YAAYQ,GAERJ,KAAKiD,SAAW,GAChBjD,KAAKqM,gBAAkB,GACvBrM,KAAKsM,YAAc,EACnBtM,KAAKkF,KAAK9E,GAMNR,KAAKQ,GAGT,GAAKA,GAASA,EAAKM,OAId,GAAI6L,MAAMC,QAAQpM,EAAK,IAGxB,IAAK,IAAIO,EAAI,EAAGA,EAAIP,EAAKM,SAAUC,EACnC,CAEI,MAAM8L,EAAQrM,EAAKO,GACnB,IAAI+L,EAAYD,EAAM,GAEtB,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAM/L,SAAUiM,EACpC,CACI,MAAMC,EAASH,EAAME,GAErB3M,KAAKiD,SAASwG,KAAK,CAAEoD,GAAIH,EAAWI,GAAIF,EAAQG,EAAG,IACnDL,EAAYE,OAKxB,CACI,IAAIF,EAAYtM,EAAK,GAGrB,IAAK,IAAIO,EAAI,EAAGA,EAAIP,EAAKM,SAAUC,EACnC,CACI,MAAMiM,EAASxM,EAAKO,GAEpBX,KAAKiD,SAASwG,KAAK,CAAEoD,GAAIH,EAAWI,GAAIF,EAAQG,EAAG,IACnDL,EAAYE,QA9BhB5M,KAAKiD,SAASwG,KAAK,CAAEoD,GAAI,CAAEhL,EAAG,EAAGC,EAAG,GAAKgL,GAAI,CAAEjL,EAAG,EAAGC,EAAG,GAAKiL,EAAG,IAmCpE,IAAK,IAAIpM,EAAI,EAAGA,EAAIX,KAAKiD,SAASvC,SAAUC,EAC5C,CACI,MAAMkM,GAAEA,EAAEC,GAAEA,GAAO9M,KAAKiD,SAAStC,GAC3BqM,EAAY7L,KAAKkB,MAAOyK,EAAGjL,EAAIgL,EAAGhL,IAAMiL,EAAGjL,EAAIgL,EAAGhL,IAAQiL,EAAGhL,EAAI+K,EAAG/K,IAAMgL,EAAGhL,EAAI+K,EAAG/K,IAG1F9B,KAAKiD,SAAStC,GAAGoM,EAAIC,EACrBhN,KAAKsM,aAAeU,EAEpBhN,KAAKqM,gBAAgB5C,KAAKzJ,KAAKsM,cAQhC1M,WAAWqN,GAGd,MAAMC,EAAO/L,KAAKkK,SAAWrL,KAAKsM,YAClC,IAAIa,EACAjJ,EAGJ,GAA6B,IAAzBlE,KAAKiD,SAASvC,OAEdyM,EAAYnN,KAAKiD,SAAS,GAC1BiB,EAAOgJ,OAMP,IAAK,IAAIvM,EAAI,EAAGA,EAAIX,KAAKqM,gBAAgB3L,SAAUC,EAE/C,GAAIuM,EAAOlN,KAAKqM,gBAAgB1L,GAChC,CACIwM,EAAYnN,KAAKiD,SAAStC,GAG1BuD,EAAa,IAANvD,EAAUuM,EAAOA,EAAOlN,KAAKqM,gBAAgB1L,EAAI,GACxD,MAKZuD,GAAQiJ,EAAUJ,GAAK,EACvB,MAAMF,GAAEA,EAAEC,GAAEA,GAAOK,EAGnBF,EAAIpL,EAAIgL,EAAGhL,EAAKqC,GAAQ4I,EAAGjL,EAAIgL,EAAGhL,GAClCoL,EAAInL,EAAI+K,EAAG/K,EAAKoC,GAAQ4I,EAAGhL,EAAI+K,EAAG/K,IA1HxBsK,EAAA5D,KAAO,iBACP4D,EAAAL,aAA6B,uECJlCqB,EAaTxN,YAAY+E,SANL3E,KAAA2J,MAAQ9F,EAAcwJ,KA+BzBrN,KAAKsN,SAAW3I,EAAO2I,SACvBtN,KAAKuN,SAAW5I,EAAO4I,SACvBvN,KAAKwN,MAAQ7I,EAAO6I,MACpBxN,KAAKmI,SAAWxD,EAAOwD,OACvBnI,KAAKyN,SAA0B,QAAfC,EAAA/I,EAAO8I,gBAAQ,IAAAC,EAAAA,EAAI,EAGvC9N,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CACI,MAAM0N,EAASxM,KAAKkK,UAAYrL,KAAKuN,SAAWvN,KAAKsN,UAAatN,KAAKsN,SAElErN,EAAK0E,OAAOiJ,SAMZ3N,EAAK0E,OAAOiJ,SAAmB9E,IAAI6E,EAAO,GAJ3C1N,EAAK0E,OAAOiJ,SAAW,IAAI7G,EAAAA,MAAM4G,EAAO,GAO5CtM,EAAYpB,EAAKmF,SAAUnF,EAAK0E,OAAOiJ,UAEvC3N,EAAOA,EAAKA,MAIpBL,eAAesK,EAAoB2D,GAE/B,MAAMC,EAAM5D,EAASvF,OAAOiJ,SACtBG,EAAQD,EAAIjM,EACZmM,EAAQF,EAAIhM,EAIlB,GAFAgM,EAAIjM,GAAK7B,KAAKwN,MAAM3L,EAAIgM,EACxBC,EAAIhM,GAAK9B,KAAKwN,MAAM1L,EAAI+L,EACpB7N,KAAKyN,SACT,CACI,MAAMQ,EAAevN,EAAOoN,GAIxBG,EAAejO,KAAKyN,UAEpBjL,EAAQsL,EAAK9N,KAAKyN,SAAWQ,GAIrC/D,EAASrI,IAAMkM,EAAQD,EAAIjM,GAAK,EAAIgM,EACpC3D,EAASpI,IAAMkM,EAAQF,EAAIhM,GAAK,EAAI+L,EAChC7N,KAAKmI,SAEL+B,EAAS9E,SAAWjE,KAAK+M,MAAMJ,EAAIhM,EAAGgM,EAAIjM,KClHtD,SAASsM,EAA2CjK,GAIhD,OAFIlE,KAAKD,OAAMmE,EAAOlE,KAAKD,KAAKmE,KAEvBlE,KAAKQ,MAAMP,KAAKJ,MAAQG,KAAKQ,MAAMX,OAASqE,EAAQlE,KAAKQ,MAAMX,MAG5E,SAASuO,EAA0ClK,GAE3ClE,KAAKD,OAAMmE,EAAOlE,KAAKD,KAAKmE,IAEhC,MAAMC,EAASnE,KAAKQ,MAAMX,MACpBuE,EAAUpE,KAAKQ,MAAMP,KAAKJ,MAKhC,OAAOmC,GAJKoC,EAAQnC,EAAIkC,EAAOlC,GAAKiC,EAAQC,EAAOlC,GACvCmC,EAAQlC,EAAIiC,EAAOjC,GAAKgC,EAAQC,EAAOjC,GACvCkC,EAAQjC,EAAIgC,EAAOhC,GAAK+B,EAAQC,EAAOhC,GAKvD,SAASkM,EAA4CnK,GAE7ClE,KAAKD,OAAMmE,EAAOlE,KAAKD,KAAKmE,IAGhC,IAAIF,EAAUhE,KAAKQ,MACfP,EAAO+D,EAAQ/D,KAEnB,KAAOiE,EAAOjE,EAAKH,MAEfkE,EAAU/D,EACVA,EAAOA,EAAKA,KAKhB,OAFAiE,GAAQA,EAAOF,EAAQlE,OAASG,EAAKH,KAAOkE,EAAQlE,OAE3CG,EAAKJ,MAAQmE,EAAQnE,OAASqE,EAAQF,EAAQnE,MAG3D,SAASyO,EAA2CpK,GAE5ClE,KAAKD,OAAMmE,EAAOlE,KAAKD,KAAKmE,IAGhC,IAAIF,EAAUhE,KAAKQ,MACfP,EAAO+D,EAAQ/D,KAEnB,KAAOiE,EAAOjE,EAAKH,MAEfkE,EAAU/D,EACVA,EAAOA,EAAKA,KAGhBiE,GAAQA,EAAOF,EAAQlE,OAASG,EAAKH,KAAOkE,EAAQlE,MACpD,MAAMqE,EAASH,EAAQnE,MACjBuE,EAAUnE,EAAKJ,MAKrB,OAAOmC,GAJKoC,EAAQnC,EAAIkC,EAAOlC,GAAKiC,EAAQC,EAAOlC,GACvCmC,EAAQlC,EAAIiC,EAAOjC,GAAKgC,EAAQC,EAAOjC,GACvCkC,EAAQjC,EAAIgC,EAAOhC,GAAK+B,EAAQC,EAAOhC,GAKvD,SAASoM,EAA4CrK,GAE7ClE,KAAKD,OAAMmE,EAAOlE,KAAKD,KAAKmE,IAGhC,IAAIF,EAAUhE,KAAKQ,MAEnB,KAAOwD,EAAQ/D,MAAQiE,EAAOF,EAAQ/D,KAAKH,MAEvCkE,EAAUA,EAAQ/D,KAGtB,OAAO+D,EAAQnE,MAGnB,SAAS2O,EAA2CtK,GAE5ClE,KAAKD,OAAMmE,EAAOlE,KAAKD,KAAKmE,IAGhC,IAAIF,EAAUhE,KAAKQ,MAEnB,KAAOwD,EAAQ/D,MAAQiE,EAAOF,EAAQ/D,KAAKH,MAEvCkE,EAAUA,EAAQ/D,KAEtB,MAAMkE,EAASH,EAAQnE,MAEvB,OAAOmC,EAAqBmC,EAAOlC,EAAGkC,EAAOjC,EAAGiC,EAAOhC,GDnEzCiL,EAAA5E,KAAO,mBACP4E,EAAArB,aAAqC,WCyE1C0C,EA2BT7O,YAAY8O,GAAU,GAElB1O,KAAKQ,MAAQ,KACbR,KAAK0O,UAAYA,EACjB1O,KAAK2O,YAAc,KACnB3O,KAAKD,KAAO,KAQTH,MAAMY,GAETR,KAAKQ,MAAQA,EACIA,EAAMP,MAAQO,EAAMP,KAAKH,MAAQ,EAI9CE,KAAK2O,YAAc3O,KAAK0O,QAAUN,EAAiBD,EAE9C3N,EAAMN,UAEXF,KAAK2O,YAAc3O,KAAK0O,QAAUF,EAAkBD,EAIpDvO,KAAK2O,YAAc3O,KAAK0O,QAAUJ,EAAkBD,EAExDrO,KAAKD,KAAOC,KAAKQ,MAAMT,YCzIlB6O,EAOThP,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB7O,KAAKM,KAAO,IAAImO,GAAa,GAC7BzO,KAAKM,KAAKwO,MAAMnP,EAAaoP,WAAWpK,EAAOhC,QAGnD/C,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHA,EAAK0C,MAAQ3C,KAAKM,KAAKE,MAAMX,MAC7BI,EAAOA,EAAKA,KAIpBL,eAAesK,GAEXA,EAASvH,MAAQ3C,KAAKM,KAAKqO,YAAYzE,EAASnF,aA7BtC6J,EAAApG,KAAO,QACPoG,EAAA7C,aAAqC,WA6C1CiD,EAOTpP,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB7O,KAAKH,MAAQ8E,EAAOhC,MAGxB/C,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHA,EAAK0C,MAAQ3C,KAAKH,MAClBI,EAAOA,EAAKA,MCtDxB,SAASgP,EAAYC,GAEjB,MAAMC,EAAyB,GAE/B,IAAK,IAAIxC,EAAI,EAAGA,EAAIuC,EAASxO,SAAUiM,EACvC,CACI,IAAIyC,EAAMF,EAASvC,GAEnB,GAAmB,iBAARyC,EAEPD,EAAY1F,KAAK3I,EAAqBsO,SAErC,GAAIA,aAAerO,EAAAA,QAEpBoO,EAAY1F,KAAK2F,OAIrB,CACI,IAAIC,EAAOD,EAAInF,OAAS,EAUxB,IANImF,EAFuB,iBAAhBA,EAAIE,QAELxO,EAAqBsO,EAAIE,SAIzBF,EAAIE,QAEPD,EAAO,IAAKA,EAEfF,EAAY1F,KAAK2F,IAK7B,OAAOD,EDJOH,EAAAxG,KAAO,cACPwG,EAAAjD,aAAqC,WC+B1CwD,EAOT3P,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB7O,KAAKwP,MAAQ,GACb,IAAK,IAAI7O,EAAI,EAAGA,EAAIgE,EAAO6K,MAAM9O,SAAUC,EAC3C,CACI,MAAM8O,EAAO9K,EAAO6K,MAAM7O,GACpBuO,EAAWD,EAAYQ,EAAKP,UAE5BQ,EAAYD,EAAKC,UAAY,GAAK,EAAKD,EAAKC,UAAY,EAAID,EAAKC,UAAY,GAC7EC,EAAwC,CAC1CT,SAAAA,EACAU,SAAUF,EAAY,EAAIR,EAASxO,OAASgP,EAAY,EACxDA,UAAAA,EACAG,KAAMH,EAAY,KAAMD,EAAKI,MAGjC7P,KAAKwP,MAAM/F,KAAKkG,IAIxB/P,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CACI,MAAM6P,EAAQ3O,KAAK4O,MAAM5O,KAAKkK,SAAWrL,KAAKwP,MAAM9O,QAC9C+O,EAAOxP,EAAK0E,OAAO8K,KAAOzP,KAAKwP,MAAMM,GAE3C7P,EAAKqP,QAAUG,EAAKP,SAAS,GAC7BjP,EAAK0E,OAAOqL,YAAc,GAEF,IAApBP,EAAKC,WAELzP,EAAK0E,OAAOsL,aAAehQ,EAAK4E,QAChC5E,EAAK0E,OAAOuL,cAAgBT,EAAKP,SAASxO,OAAST,EAAK4E,UAIxD5E,EAAK0E,OAAOsL,aAAeR,EAAKG,SAChC3P,EAAK0E,OAAOuL,cAAgBT,EAAKC,WAGrCzP,EAAOA,EAAKA,MAIpBL,eAAesK,EAAoB2D,GAE/B,MAAMlJ,EAASuF,EAASvF,OAClB8K,EAAO9K,EAAO8K,KAEpB9K,EAAOqL,aAAenC,EAClBlJ,EAAOqL,aAAerL,EAAOsL,eAGzBtL,EAAO8K,KAAKI,KAEZlL,EAAOqL,YAAcrL,EAAOqL,YAAcrL,EAAOsL,aAKjDtL,EAAOqL,YAAcrL,EAAOsL,aAAe,MAKnD,MAAME,EAAUxL,EAAOqL,YAAcrL,EAAOuL,cAAiB,KAAa,EAG1EhG,EAASoF,QAAUG,EAAKP,SAASiB,IAAUV,EAAKP,SAASO,EAAKP,SAASxO,OAAS,IAAMK,EAAAA,QAAQqP,OAjFpFb,EAAA/G,KAAO,iBACP+G,EAAAxD,aAAqC,WAsG1CsE,EAOTzQ,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB,MAAMY,EAAO9K,EAAO8K,KACdP,EAAWD,EAAYQ,EAAKP,UAE5BQ,EAAYD,EAAKC,UAAY,GAAK,EAAKD,EAAKC,UAAY,EAAID,EAAKC,UAAY,GAEnF1P,KAAKyP,KAAO,CACRP,SAAAA,EACAU,SAAUF,EAAY,EAAIR,EAASxO,OAASgP,EAAY,EACxDA,UAAAA,EACAG,KAAMH,EAAY,KAAMD,EAAKI,MAIrCjQ,cAAcY,GAEV,IAAIP,EAAOO,EACX,MAAMiP,EAAOzP,KAAKyP,KAElB,KAAOxP,GAEHA,EAAKqP,QAAUG,EAAKP,SAAS,GAC7BjP,EAAK0E,OAAOqL,YAAc,GAEF,IAApBP,EAAKC,WAELzP,EAAK0E,OAAOsL,aAAehQ,EAAK4E,QAChC5E,EAAK0E,OAAOuL,cAAgBT,EAAKP,SAASxO,OAAST,EAAK4E,UAIxD5E,EAAK0E,OAAOsL,aAAeR,EAAKG,SAChC3P,EAAK0E,OAAOuL,cAAgBT,EAAKC,WAGrCzP,EAAOA,EAAKA,KAIpBL,eAAesK,EAAoB2D,GAE/B,MAAM4B,EAAOzP,KAAKyP,KACZ9K,EAASuF,EAASvF,OAExBA,EAAOqL,aAAenC,EAClBlJ,EAAOqL,aAAerL,EAAOsL,eAGzBR,EAAKI,KAELlL,EAAOqL,YAAcrL,EAAOqL,YAAcrL,EAAOsL,aAKjDtL,EAAOqL,YAAcrL,EAAOsL,aAAe,MAKnD,MAAME,EAAUxL,EAAOqL,YAAcrL,EAAOuL,cAAiB,KAAa,EAG1EhG,EAASoF,QAAUG,EAAKP,SAASiB,IAAUV,EAAKP,SAASO,EAAKP,SAASxO,OAAS,IAAMK,EAAAA,QAAQqP,OA1EpFC,EAAA7H,KAAO,iBACP6H,EAAAtE,aAAqC,WCjM1CuE,EAOT1Q,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OAUzB7O,KAAKH,MAAQ8E,EAAO4L,UAGxB3Q,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHA,EAAKsQ,UAAYhN,EAAavD,KAAKH,OACnCI,EAAOA,EAAKA,MAvBNqQ,EAAA9H,KAAO,YACP8H,EAAAvE,aAAqC,WCA1CyE,EAUT5Q,YAAY+E,GALZ3E,KAAA2J,MAAQ9F,EAAc+F,MAoBlB5J,KAAKyQ,QAAU9L,EAAO8L,QAAUvP,EAChClB,KAAKY,MAAQ+D,EAAO/D,MAAQM,EAC5BlB,KAAK0Q,SAAW/L,EAAO+L,SAG3B9Q,cAAcY,GAEV,IAAIyJ,EAAQ,EACRhK,EAAOO,EAEX,KAAOP,GACP,CACI,IAAIqB,EAIAA,EAFAtB,KAAKyQ,QAEGzQ,KAAKY,MAASZ,KAAKyQ,QAAUxG,EAI7B9I,KAAKkK,SAAWlK,KAAKC,GAAK,EAGtCnB,EAAKmF,SAAW9D,EACZtB,KAAK0Q,WAELzQ,EAAKoF,SAASxD,EAAI7B,KAAK0Q,SACvBrP,EAAYC,EAAOrB,EAAKoF,WAE5BpF,EAAOA,EAAKA,OACVgK,IArDIuG,EAAAhI,KAAO,aACPgI,EAAAzE,aAAqC,WCF1C4E,EAOT/Q,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB7O,KAAKM,KAAO,IAAImO,GAAa,GAC7BzO,KAAKM,KAAKwO,MAAMnP,EAAaoP,WAAWpK,EAAOlC,QAGnD7C,cAAcY,GAEV,IAAIP,EAAOO,EACX,MAAMiC,EAAQzC,KAAKM,KAAKE,MAAMX,MACxB0F,EAAOvD,EAAqBS,EAAMR,EAAGQ,EAAMP,EAAGO,EAAMN,GAE1D,KAAOlC,GAEHA,EAAKsF,KAAOA,EACZtF,EAAOA,EAAKA,KAIpBL,eAAesK,GAEXA,EAAS3E,KAAOvF,KAAKM,KAAKqO,YAAYzE,EAASnF,aA/BrC4L,EAAAnI,KAAO,QACPmI,EAAA5E,aAAqC,WA+C1C6E,EAOThR,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB,IAAIpM,EAAQkC,EAAOlC,MAEK,MAApBA,EAAMG,OAAO,GAEbH,EAAQA,EAAMI,OAAO,GAEQ,IAAxBJ,EAAMK,QAAQ,QAEnBL,EAAQA,EAAMI,OAAO,IAGzB7C,KAAKH,MAAQkD,SAASN,EAAO,IAGjC7C,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHA,EAAKsF,KAAOvF,KAAKH,MACjBI,EAAOA,EAAKA,MAjCN2Q,EAAApI,KAAO,cACPoI,EAAA7E,aAAqC,WCvD1C8E,EAQTjR,YAAY+E,GAHL3E,KAAA2J,MAAQ9F,EAAcgL,OAUzB7O,KAAK8P,MAAQ,EACb9P,KAAKkP,SAAWvK,EAAOuK,SAAS7F,IAAK+F,GAAwB,iBAARA,EAAmBtO,EAAqBsO,GAAOA,GAGxGxP,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHA,EAAKqP,QAAUtP,KAAKkP,SAASlP,KAAK8P,SAC5B9P,KAAK8P,OAAS9P,KAAKkP,SAASxO,SAE9BV,KAAK8P,MAAQ,GAEjB7P,EAAOA,EAAKA,MA5BN4Q,EAAArI,KAAO,iBACPqI,EAAA9E,aAAqC,KCXvD,MAAM+E,EAAc,IAAI/J,EAAAA,MAOlBgK,EAAa,CACf,IACA,MACA,OACA,QACA,SACA,KACA,UACA,QACA,MACA,OACA,QACA,OACA,QACA,OACA,QACA,QACA,OACA,OACA,MACA,OACA,MACA,QACA,QACA,SACA,QACA,MACA,QACA,QACA,OACA,MACA,MACA,MACA,SACA,QACA,OACA,MACA,OACA,OACA,MACA,QAMEC,EAAc,IAAIC,OACpB,CAGI,yCACFC,OAAOH,GAAYI,KAAK,KAC1B,WA4DSC,EAaTxR,YAAY+E,SAiBR,GAxBG3E,KAAA2J,MAAQ9F,EAAcwJ,KAwBrB1I,EAAO0M,KAEP,GAA2B,mBAAhB1M,EAAO0M,KAEdrR,KAAKqR,KAAO1M,EAAO0M,UAInB,IAEIrR,KAAKqR,KAzFzB,SAAmBC,GAEf,MAAMC,EAAUD,EAAWE,MAAMR,GAEjC,IAAK,IAAIrQ,EAAI4Q,EAAQ7Q,OAAS,EAAGC,GAAK,IAAKA,EAEnCoQ,EAAWjO,QAAQyO,EAAQ5Q,KAAO,IACpC4Q,EAAQ5Q,WAAa4Q,EAAQ5Q,MAKnC,OAHA2Q,EAAaC,EAAQJ,KAAK,IAGnB,IAAIM,SAAS,cAAeH,MA6EPI,CAAU/M,EAAO0M,MAEjC,MAAO/N,GAECrC,GAEAqI,QAAQC,MAAM,iDAAkDjG,GAEpEtD,KAAKqR,KAAO,UAMhBpQ,GAEAqI,QAAQC,MAAM,qDAGlBvJ,KAAKqR,KAAO,CAACxP,GAAMA,GAEvB7B,KAAKM,KAAO,IAAImO,GAAa,GAC7BzO,KAAKM,KAAKwO,MAAMnP,EAAaoP,WAAWpK,EAAOgJ,QAC/C3N,KAAK2R,QAAwB,QAAdjE,EAAA/I,EAAOgN,eAAO,IAAAjE,EAAAA,EAAI,EAGrC9N,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CAKIA,EAAK0E,OAAOiN,aAAe3R,EAAKmF,SAE3BnF,EAAK0E,OAAOkN,aAMZ5R,EAAK0E,OAAOkN,aAAuB7I,SAAS/I,EAAKoF,UAJlDpF,EAAK0E,OAAOkN,aAAe,IAAI9K,EAAAA,MAAM9G,EAAK4B,EAAG5B,EAAK6B,GAOtD7B,EAAK0E,OAAOmN,SAAW,EAGvB,MAAMC,EAAQ5Q,KAAKkK,UAAY,EAAIrL,KAAK2R,SAAY3R,KAAK2R,QAEzD1R,EAAK0E,OAAOqN,UAAYD,EAExB9R,EAAOA,EAAKA,MAIpBL,eAAesK,EAAoB2D,GAG/B,MAAMF,EAAQ3N,KAAKM,KAAKqO,YAAYzE,EAASnF,YAAcmF,EAASvF,OAAOqN,UAE3E9H,EAASvF,OAAOmN,UAAYnE,EAAQE,EAEpCiD,EAAYjP,EAAIqI,EAASvF,OAAOmN,SAChChB,EAAYhP,EAAI9B,KAAKqR,KAAKP,EAAYjP,GACtCR,EAAY6I,EAASvF,OAAOiN,aAAcd,GAC1C5G,EAAS7E,SAASxD,EAAIqI,EAASvF,OAAOkN,aAAahQ,EAAIiP,EAAYjP,EACnEqI,EAAS7E,SAASvD,EAAIoI,EAASvF,OAAOkN,aAAa/P,EAAIgP,EAAYhP,GA3GzDsP,EAAA5I,KAAO,WACP4I,EAAArF,aAAqC,WCvH1CkG,EAAbrS,cAKII,KAAA2J,MAAQ9F,EAAc+F,MAGtBhK,cAAcsS,KANAD,EAAAzJ,KAAO,aACPyJ,EAAAlG,aAAqC,WCE1CoG,EAOTvS,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB7O,KAAKkP,SAAWvK,EAAOuK,SAAS7F,IAAK+F,GAAwB,iBAARA,EAAmBtO,EAAqBsO,GAAOA,GAGxGxP,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CACI,MAAM6P,EAAQ3O,KAAK4O,MAAM5O,KAAKkK,SAAWrL,KAAKkP,SAASxO,QAEvDT,EAAKqP,QAAUtP,KAAKkP,SAASY,GAE7B7P,EAAOA,EAAKA,OAzBNkS,EAAA3J,KAAO,gBACP2J,EAAApG,aAAqC,WCD1CqG,GAWTxS,YAAY+E,GANL3E,KAAA2J,MAAQ9F,EAAcgL,OA6BzB7O,KAAKsN,SAAW3I,EAAO2I,SAAWpM,EAClClB,KAAKuN,SAAW5I,EAAO4I,SAAWrM,EAClClB,KAAKqS,SAAW1N,EAAO0N,SAAWnR,EAClClB,KAAKyN,SAAW9I,EAAO8I,SAAWvM,EAClClB,KAAKwN,MAAQ7I,EAAO6I,MAAQtM,EAGhCtB,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAECD,KAAKsN,WAAatN,KAAKuN,SAEvBtN,EAAKmF,UAAYpF,KAAKuN,SAItBtN,EAAKmF,UAAajE,KAAKkK,UAAYrL,KAAKuN,SAAWvN,KAAKsN,UAAatN,KAAKsN,SAE9ErN,EAAK0E,OAAO2N,SAAYnR,KAAKkK,UAAYrL,KAAKyN,SAAWzN,KAAKqS,UAAarS,KAAKqS,SAEhFpS,EAAOA,EAAKA,KAIpBL,eAAesK,EAAoB2D,GAE/B,GAAI7N,KAAKwN,MACT,CACI,MAAM+E,EAAWrI,EAASvF,OAAO2N,SAEjCpI,EAASvF,OAAO2N,UAAYtS,KAAKwN,MAAQK,EACzC3D,EAAS9E,WAAa8E,EAASvF,OAAO2N,SAAWC,GAAY,EAAI1E,OAIjE3D,EAAS9E,UAAY8E,EAASvF,OAAO2N,SAAWzE,GAtE1CuE,GAAA5J,KAAO,WACP4J,GAAArG,aAAqC,WAwF1CyG,GAQT5S,YAAY+E,GAHL3E,KAAA2J,MAAQ9F,EAAcgL,OAczB7O,KAAK4I,IAAMjE,EAAOiE,IAAM1H,EACxBlB,KAAK6I,IAAMlE,EAAOkE,IAAM3H,EAG5BtB,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAECD,KAAK4I,MAAQ5I,KAAK6I,IAElB5I,EAAKmF,UAAYpF,KAAK6I,IAItB5I,EAAKmF,UAAajE,KAAKkK,UAAYrL,KAAK6I,IAAM7I,KAAK4I,KAAQ5I,KAAK4I,IAGpE3I,EAAOA,EAAKA,MApCNuS,GAAAhK,KAAO,iBACPgK,GAAAzG,aAAqC,WAsD1C0G,GAQT7S,YAAY+E,GAHL3E,KAAA2J,MAAQ9F,EAAcwJ,KAAO,EAUhCrN,KAAKoF,UAAYT,EAAOS,UAAY,GAAKlE,EAG7CtB,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHA,EAAKmF,SAAWpF,KAAKoF,SAErBnF,EAAOA,EAAKA,MAxBNwS,GAAAjK,KAAO,aACPiK,GAAA1G,aAAqC,WCtJ1C2G,GAQT9S,YAAY+E,SAHL3E,KAAA2J,MAAQ9F,EAAcgL,OAezB7O,KAAKM,KAAO,IAAImO,GAAa,GAC7BzO,KAAKM,KAAKwO,MAAMnP,EAAaoP,WAAWpK,EAAOW,QAC/CtF,KAAK2R,QAAwB,QAAdjE,EAAA/I,EAAOgN,eAAO,IAAAjE,EAAAA,EAAI,EAGrC9N,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CACI,MAAM8R,EAAQ5Q,KAAKkK,UAAY,EAAIrL,KAAK2R,SAAY3R,KAAK2R,QAEzD1R,EAAK0E,OAAOgO,UAAYZ,EACxB9R,EAAKqF,MAAMzD,EAAI5B,EAAKqF,MAAMxD,EAAI9B,KAAKM,KAAKE,MAAMX,MAAQkS,EAEtD9R,EAAOA,EAAKA,MAIpBL,eAAesK,GAEXA,EAAS5E,MAAMzD,EAAIqI,EAAS5E,MAAMxD,EAAI9B,KAAKM,KAAKqO,YAAYzE,EAASnF,YAAcmF,EAASvF,OAAOgO,WAxCzFD,GAAAlK,KAAO,QACPkK,GAAA3G,aAAqC,WAyD1C6G,GAQThT,YAAY+E,GAHL3E,KAAA2J,MAAQ9F,EAAcgL,OAczB7O,KAAK4I,IAAMjE,EAAOiE,IAClB5I,KAAK6I,IAAMlE,EAAOkE,IAGtBjJ,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CACI,MAAMqF,EAASnE,KAAKkK,UAAYrL,KAAK6I,IAAM7I,KAAK4I,KAAQ5I,KAAK4I,IAE7D3I,EAAKqF,MAAMzD,EAAI5B,EAAKqF,MAAMxD,EAAIwD,EAE9BrF,EAAOA,EAAKA,OA/BN2S,GAAApK,KAAO,cACPoK,GAAA7G,aAAqC,WCpD1C8G,GAuBTjT,YAAY+E,GAHZ3E,KAAA2J,MAAQ9F,EAAc+F,MAclB,MAAMkJ,EAAaD,GAAmBE,OAAOpO,EAAO6D,MAEpD,IAAKsK,EAED,MAAM,IAAIE,mCAAmCrO,EAAO6D,SAExDxI,KAAKiT,MAAQ,IAAIH,EAAWnO,EAAOvE,MAzBhCR,qBAAqB0I,EAA8B4K,GAEtDL,GAAmBE,OAAOG,GAAgB5K,EAAYE,MAAQF,EA0BlE1I,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHD,KAAKiT,MAAME,WAAWlT,GACtBA,EAAOA,EAAKA,MAhDN4S,GAAArK,KAAO,aACPqK,GAAA9G,aAAqC,KAKpC8G,GAAAE,OAA2C,GA+C9DF,GAAmBO,cAAchH,GACjCyG,GAAmBO,cAAcxH,GACjCiH,GAAmBO,cAAcpH,GACjC6G,GAAmBO,cAAcpH,EAAO,gBCxE3BqH,GAOTzT,YAAY+E,GAFL3E,KAAA2J,MAAQ9F,EAAcgL,OASzB7O,KAAKsP,QAAoC,iBAAnB3K,EAAO2K,QAAuBxO,EAAqB6D,EAAO2K,SAAW3K,EAAO2K,QAGtG1P,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GAEHA,EAAKqP,QAAUtP,KAAKsP,QAEpBrP,EAAOA,EAAKA,MAvBNoT,GAAA7K,KAAO,gBACP6K,GAAAtH,aAAqC,WCE1CuH,GAQT1T,YAAY+E,SAHL3E,KAAA2J,MAAQ9F,EAAcwJ,KAezBrN,KAAKM,KAAO,IAAImO,GAAa,GAC7BzO,KAAKM,KAAKwO,MAAMnP,EAAaoP,WAAWpK,EAAOgJ,QAC/C3N,KAAK2R,QAAwB,QAAdjE,EAAA/I,EAAOgN,eAAO,IAAAjE,EAAAA,EAAI,EAGrC9N,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CACI,MAAM8R,EAAQ5Q,KAAKkK,UAAY,EAAIrL,KAAK2R,SAAY3R,KAAK2R,QAEzD1R,EAAK0E,OAAOqN,UAAYD,EACnB9R,EAAK0E,OAAOiJ,SAMZ3N,EAAK0E,OAAOiJ,SAAmB9E,IAAI9I,KAAKM,KAAKE,MAAMX,MAAQkS,EAAM,GAJlE9R,EAAK0E,OAAOiJ,SAAW,IAAI7G,EAAAA,MAAM/G,KAAKM,KAAKE,MAAMX,MAAQkS,EAAM,GAOnE1Q,EAAYpB,EAAKmF,SAAUnF,EAAK0E,OAAOiJ,UAEvC3N,EAAOA,EAAKA,MAIpBL,eAAesK,EAAoB2D,GAE/B,MAAMF,EAAQ3N,KAAKM,KAAKqO,YAAYzE,EAASnF,YAAcmF,EAASvF,OAAOqN,UACrElE,EAAM5D,EAASvF,OAAOiJ,SAE5BtL,EAAUwL,GACVtL,EAAQsL,EAAKH,GACbzD,EAASrI,GAAKiM,EAAIjM,EAAIgM,EACtB3D,EAASpI,GAAKgM,EAAIhM,EAAI+L,GAvDZyF,GAAA9K,KAAO,YACP8K,GAAAvH,aAAqC,WAyE1CwH,GAQT3T,YAAY+E,GAHL3E,KAAA2J,MAAQ9F,EAAcwJ,KAczBrN,KAAK4I,IAAMjE,EAAOiE,IAClB5I,KAAK6I,IAAMlE,EAAOkE,IAGtBjJ,cAAcY,GAEV,IAAIP,EAAOO,EAEX,KAAOP,GACP,CACI,MAAM0N,EAASxM,KAAKkK,UAAYrL,KAAK6I,IAAM7I,KAAK4I,KAAQ5I,KAAK4I,IAExD3I,EAAK0E,OAAOiJ,SAMZ3N,EAAK0E,OAAOiJ,SAAmB9E,IAAI6E,EAAO,GAJ3C1N,EAAK0E,OAAOiJ,SAAW,IAAI7G,EAAAA,MAAM4G,EAAO,GAO5CtM,EAAYpB,EAAKmF,SAAUnF,EAAK0E,OAAOiJ,UAEvC3N,EAAOA,EAAKA,MAIpBL,eAAesK,EAAoB2D,GAE/B,MAAMD,EAAW1D,EAASvF,OAAOiJ,SAEjC1D,EAASrI,GAAK+L,EAAS/L,EAAIgM,EAC3B3D,EAASpI,GAAK8L,EAAS9L,EAAI+L,GAjDjB0F,GAAA/K,KAAO,kBACP+K,GAAAxH,aAAqC,qkBCrGvD7F,EAAQsN,iBAAiBC,GACzBvN,EAAQsN,iBAAiBE,GACzBxN,EAAQsN,iBAAiBG,GACzBzN,EAAQsN,iBAAiBI,GACzB1N,EAAQsN,iBAAiBK,GACzB3N,EAAQsN,iBAAiBM,GACzB5N,EAAQsN,iBAAiBO,GACzB7N,EAAQsN,iBAAiBQ,GACzB9N,EAAQsN,iBAAiBS,GACzB/N,EAAQsN,iBAAiBU,GACzBhO,EAAQsN,iBAAiBW,GACzBjO,EAAQsN,iBAAiBY,GACzBlO,EAAQsN,iBAAiBa,GACzBnO,EAAQsN,iBAAiBc,IACzBpO,EAAQsN,iBAAiBe,IACzBrO,EAAQsN,iBAAiBgB,IACzBtO,EAAQsN,iBAAiBiB,IACzBvO,EAAQsN,iBAAiBkB,IACzBxO,EAAQsN,iBAAiBmB,IACzBzO,EAAQsN,iBAAiBoB,IACzB1O,EAAQsN,iBAAiBqB,IACzB3O,EAAQsN,iBAAiBsB,oDCNgBC,EAAAA,UAAzCnV,kCAEYI,KAAAgV,YAAoC,KACpChV,KAAAiV,WAAmC,KACnCjV,KAAAkV,YAAc,EAEtBC,iBAEI,OAAOnV,KAAKgV,YAGhBI,gBAEI,OAAOpV,KAAKiV,WAGhBI,iBAEI,OAAOrV,KAAKkV,YAGTtV,YAAuC0V,GAG1C,GAAIA,EAAS5U,OAAS,EAGlB,IAAK,IAAIC,EAAI,EAAGA,EAAI2U,EAAS5U,OAAQC,IAGjCX,KAAKuL,SAAS+J,EAAS3U,QAI/B,CACI,MAAM4U,EAAQD,EAAS,GAGnBC,EAAM7P,QAEN6P,EAAM7P,OAAOC,YAAY4P,GAG7BA,EAAM7P,OAAS1F,KACfA,KAAKwV,WAAY,EAGjBD,EAAME,UAAUC,WAAa,EAGzB1V,KAAKiV,YAELjV,KAAKiV,WAAWvQ,UAAY6Q,EAC5BA,EAAM9Q,UAAYzE,KAAKiV,WACvBjV,KAAKiV,WAAaM,GAKlBvV,KAAKgV,YAAchV,KAAKiV,WAAaM,IAIvCvV,KAAKkV,YAGPlV,KAAK2V,YAGL3V,KAAK4V,mBACL5V,KAAKiJ,KAAK,aAAcsM,EAAOvV,KAAMA,KAAKkV,aAC1CK,EAAMtM,KAAK,QAASjJ,MAGxB,OAAOsV,EAAS,GAGb1V,WAAoC2V,EAAUzF,GAEjD,GAAIA,EAAQ,GAAKA,EAAQ9P,KAAKkV,YAE1B,MAAM,IAAIlC,+BAA+BlD,+BAAmC9P,KAAKkV,eAGjFK,EAAM7P,QAEN6P,EAAM7P,OAAOC,YAAY4P,GAG7BA,EAAM7P,OAAS1F,KACfA,KAAKwV,WAAY,EAGjBD,EAAME,UAAUC,WAAa,EAE7B,MAAMhU,EAAK6T,EAGX,GAAKvV,KAAKgV,YAKL,GAAc,IAAVlF,EAEL9P,KAAKgV,YAAYvQ,UAAY/C,EAC7BA,EAAEgD,UAAY1E,KAAKgV,YACnBhV,KAAKgV,YAActT,OAGlB,GAAIoO,IAAU9P,KAAKkV,YAEpBlV,KAAKiV,WAAWvQ,UAAYhD,EAC5BA,EAAE+C,UAAYzE,KAAKiV,WACnBjV,KAAKiV,WAAavT,MAKtB,CACI,IAAIf,EAAI,EACJkV,EAAS7V,KAAKgV,YAElB,KAAOrU,EAAImP,GAEP+F,EAASA,EAAOnR,YACd/D,EAGNkV,EAAOpR,UAAUC,UAAYhD,EAC7BA,EAAE+C,UAAYoR,EAAOpR,UACrB/C,EAAEgD,UAAYmR,EACdA,EAAOpR,UAAY/C,OAhCnB1B,KAAKgV,YAAchV,KAAKiV,WAAavT,EA8CzC,QAVE1B,KAAKkV,YAGPlV,KAAK2V,YAGL3V,KAAK4V,iBAAiB9F,GACtByF,EAAMtM,KAAK,QAASjJ,MACpBA,KAAKiJ,KAAK,aAAcsM,EAAOvV,KAAM8P,GAE9ByF,EAUJ3V,cAAuC2V,EAAUO,GAEpD,GAAIA,EAASpQ,SAAW1F,KAEpB,MAAM,IAAIgT,MAAM,qEAmCpB,OAhCIuC,EAAM7P,QAEN6P,EAAM7P,OAAOC,YAAY4P,GAG7BA,EAAM7P,OAAS1F,KACfA,KAAKwV,WAAY,EAGjBD,EAAME,UAAUC,WAAa,EAG5BI,EAA6BrR,UAAUC,UAAa6Q,EACpDA,EAAiC9Q,UAAaqR,EAA6BrR,UAC3E8Q,EAAiC7Q,UAAaoR,EAC9CA,EAA6BrR,UAAa8Q,EACvCvV,KAAKgV,cAAgBc,IAErB9V,KAAKgV,YAAeO,KAItBvV,KAAKkV,YAGPlV,KAAK2V,YAGL3V,KAAK4V,mBACL5V,KAAKiJ,KAAK,aAAcsM,EAAOvV,KAAMA,KAAKkV,aAC1CK,EAAMtM,KAAK,QAASjJ,MAEbuV,EAUJ3V,cAAuC2V,EAAUO,GAEpD,GAAIA,EAASpQ,SAAW1F,KAEpB,MAAM,IAAIgT,MAAM,qEAmCpB,OAhCIuC,EAAM7P,QAEN6P,EAAM7P,OAAOC,YAAY4P,GAG7BA,EAAM7P,OAAS1F,KACfA,KAAKwV,WAAY,EAGjBD,EAAME,UAAUC,WAAa,EAG5BI,EAA6BpR,UAAUD,UAAa8Q,EACpDA,EAAiC7Q,UAAaoR,EAA6BpR,UAC3E6Q,EAAiC9Q,UAAaqR,EAC9CA,EAA6BpR,UAAa6Q,EACvCvV,KAAKiV,aAAea,IAEpB9V,KAAKiV,WAAcM,KAIrBvV,KAAKkV,YAGPlV,KAAK2V,YAGL3V,KAAK4V,mBACL5V,KAAKiJ,KAAK,aAAcsM,EAAOvV,KAAMA,KAAKkV,aAC1CK,EAAMtM,KAAK,QAASjJ,MAEbuV,EAGJ3V,aAAa2V,EAAsBQ,GAEtC,GAAIR,IAAUQ,GAAUR,EAAM7P,SAAW1F,MAAQ+V,EAAOrQ,SAAW1F,KAE/D,OAGJ,MAAMyE,UAAEA,EAASC,UAAEA,GAAe6Q,EAEjCA,EAA0B9Q,UAAasR,EAA2BtR,UAClE8Q,EAA0B7Q,UAAaqR,EAA2BrR,UAClEqR,EAA2BtR,UAAYA,EACvCsR,EAA2BrR,UAAYA,EAEpC1E,KAAKgV,cAAgBO,EAErBvV,KAAKgV,YAAce,EAEd/V,KAAKgV,cAAgBe,IAE1B/V,KAAKgV,YAAcO,GAEnBvV,KAAKiV,aAAeM,EAEpBvV,KAAKiV,WAAac,EAEb/V,KAAKiV,aAAec,IAEzB/V,KAAKiV,WAAaM,GAGtBvV,KAAK4V,mBAGFhW,cAAc2V,GAEjB,IAAIzF,EAAQ,EACRkG,EAAOhW,KAAKgV,YAEhB,KAAOgB,GAECA,IAAST,GAIbS,EAAOA,EAAKtR,YACVoL,EAEN,IAAKkG,EAED,MAAM,IAAIhD,MAAM,4DAGpB,OAAOlD,EAGXlQ,cAAc2V,EAAsBzF,GAEhC,GAAIA,EAAQ,GAAKA,GAAS9P,KAAKkV,YAE3B,MAAM,IAAIlC,mBAAmBlD,+BAAmC9P,KAAKkV,eAEzE,GAAIK,EAAM7P,SAAW1F,KAEjB,MAAM,IAAIgT,MAAM,4DAwBpB,GApBKuC,EAA0B7Q,YAE1B6Q,EAA0B7Q,UAAUD,UAAa8Q,EAA0B9Q,WAE3E8Q,EAA0B9Q,YAE1B8Q,EAA0B9Q,UAAUC,UAAa6Q,EAA0B7Q,WAE5E1E,KAAKgV,cAAiBO,IAEtBvV,KAAKgV,YAAeO,EAA0B7Q,WAE9C1E,KAAKiV,aAAgBM,IAErBvV,KAAKiV,WAAcM,EAA0B9Q,WAEhD8Q,EAA0B7Q,UAAY,KACtC6Q,EAA0B9Q,UAAY,KAGlCzE,KAAKgV,YAIL,GAAc,IAAVlF,EAEL9P,KAAKgV,YAAYvQ,UAAa8Q,EAC7BA,EAA0B7Q,UAAY1E,KAAKgV,YAC5ChV,KAAKgV,YAAeO,OAEnB,GAAIzF,IAAU9P,KAAKkV,YAEpBlV,KAAKiV,WAAWvQ,UAAa6Q,EAC5BA,EAA0B9Q,UAAYzE,KAAKiV,WAC5CjV,KAAKiV,WAAcM,MAGvB,CACI,IAAI5U,EAAI,EACJkV,EAAS7V,KAAKgV,YAElB,KAAOrU,EAAImP,GAEP+F,EAASA,EAAOnR,YACd/D,EAENkV,EAAOpR,UAAUC,UAAa6Q,EAC7BA,EAA0B9Q,UAAYoR,EAAOpR,UAC7C8Q,EAA0B7Q,UAAYmR,EACvCA,EAAOpR,UAAa8Q,OA3BpBvV,KAAKgV,YAAchV,KAAKiV,WAAcM,EA8B1CvV,KAAK4V,iBAAiB9F,GAGnBlQ,eAA0C0V,GAG7C,GAAIA,EAAS5U,OAAS,EAGlB,IAAK,IAAIC,EAAI,EAAGA,EAAI2U,EAAS5U,OAAQC,IAEjCX,KAAK2F,YAAY2P,EAAS3U,QAIlC,CACI,MAAM4U,EAAQD,EAAS,GAGvB,GAAIC,EAAM7P,SAAW1F,KAAM,OAAO,KAElCuV,EAAM7P,OAAS,KAEf6P,EAAME,UAAUC,WAAa,EAGzBH,EAAM7Q,YAEN6Q,EAAM7Q,UAAUD,UAAY8Q,EAAM9Q,WAElC8Q,EAAM9Q,YAEN8Q,EAAM9Q,UAAUC,UAAY6Q,EAAM7Q,WAElC1E,KAAKgV,cAAgBO,IAErBvV,KAAKgV,YAAcO,EAAM7Q,WAEzB1E,KAAKiV,aAAeM,IAEpBvV,KAAKiV,WAAaM,EAAM9Q,WAG5B8Q,EAAM7Q,UAAY,KAClB6Q,EAAM9Q,UAAY,OAGhBzE,KAAKkV,YAGPlV,KAAK2V,YAGL3V,KAAK4V,mBACLL,EAAMtM,KAAK,UAAWjJ,MACtBA,KAAKiJ,KAAK,eAAgBsM,EAAOvV,MAGrC,OAAOsV,EAAS,GAGb1V,WAAWkQ,GAEd,GAAIA,EAAQ,GAAKA,GAAS9P,KAAKkV,YAE3B,MAAM,IAAIlC,4BAA4BlD,sBAG1C,GAAc,IAAVA,EAEA,OAAO9P,KAAKgV,YAGX,GAAIlF,IAAU9P,KAAKkV,YAEpB,OAAOlV,KAAKiV,WAIhB,IAAItU,EAAI,EACJkV,EAAS7V,KAAKgV,YAElB,KAAOrU,EAAImP,GAEP+F,EAASA,EAAOnR,YACd/D,EAGN,OAAOkV,EAGJjW,cAAckQ,GAEjB,MAAMyF,EAAQvV,KAAKiW,WAAWnG,GAqC9B,OAlCAyF,EAAM7P,OAAS,KACf6P,EAAME,UAAUC,WAAa,EAEzBH,EAAM7Q,YAEN6Q,EAAM7Q,UAAUD,UAAY8Q,EAAM9Q,WAElC8Q,EAAM9Q,YAEN8Q,EAAM9Q,UAAUC,UAAY6Q,EAAM7Q,WAElC1E,KAAKgV,cAAgBO,IAErBvV,KAAKgV,YAAcO,EAAM7Q,WAEzB1E,KAAKiV,aAAeM,IAEpBvV,KAAKiV,WAAaM,EAAM9Q,WAG5B8Q,EAAM7Q,UAAY,KAClB6Q,EAAM9Q,UAAY,OAGhBzE,KAAKkV,YAGPlV,KAAK2V,YAGL3V,KAAK4V,iBAAiB9F,GACtByF,EAAMtM,KAAK,UAAWjJ,MACtBA,KAAKiJ,KAAK,eAAgBsM,EAAOvV,KAAM8P,GAEhCyF,EAGJ3V,eAAesW,EAAa,EAAGC,EAAWnW,KAAKkV,aAElD,MAAMkB,EAAQF,EACRrV,EAAMsV,EACNE,EAAQxV,EAAMuV,EAEpB,GAAIC,EAAQ,GAAKA,GAASxV,EAC1B,CACI,MAAMyV,EAA6B,GACnC,IAAIf,EAAQvV,KAAKgV,YAEjB,IAAK,IAAIrU,EAAI,EAAGA,GAAKE,GAAO0U,IAAS5U,EAAG4U,EAAQA,EAAM7Q,UAE9C/D,GAAKyV,GAELE,EAAQ7M,KAAK8L,GAKrB,MAAM9Q,EAAY6R,EAAQ,GAAG7R,UAEvBC,EAAY4R,EAAQA,EAAQ5V,OAAS,GAAGgE,UAEzCA,EASDA,EAAUD,UAAYA,EALtBzE,KAAKiV,WAAaxQ,EAOjBA,EASDA,EAAUC,UAAYA,EALtB1E,KAAKgV,YAActQ,EAQvB,IAAK,IAAI/D,EAAI,EAAGA,EAAI2V,EAAQ5V,SAAUC,EAGlC2V,EAAQ3V,GAAG+E,OAAS,KAChB4Q,EAAQ3V,GAAG8U,YAEXa,EAAQ3V,GAAG8U,UAAUC,WAAa,GAEtCY,EAAQ3V,GAAG+D,UAAY,KACvB4R,EAAQ3V,GAAG8D,UAAY,KAG3BzE,KAAK2V,YAEL3V,KAAK4V,iBAAiBM,GAEtB,IAAK,IAAIvV,EAAI,EAAGA,EAAI2V,EAAQ5V,SAAUC,EAElC2V,EAAQ3V,GAAGsI,KAAK,UAAWjJ,MAC3BA,KAAKiJ,KAAK,eAAgBqN,EAAQ3V,GAAIX,KAAMW,GAGhD,OAAO2V,EAEN,GAAc,IAAVD,GAAoC,IAArBrW,KAAKkV,YAEzB,MAAO,GAGX,MAAM,IAAIqB,WAAW,oEAOzB3W,kBASI,IAAI2V,EACAtV,EAEJ,IAVAD,KAAK2V,YAEL3V,KAAKyV,UAAUe,gBAAgBxW,KAAK0F,OAAO+P,WAG3CzV,KAAKyW,WAAazW,KAAK2C,MAAQ3C,KAAK0F,OAAO+Q,WAKtClB,EAAQvV,KAAKgV,YAAaO,EAAOA,EAAQtV,EAE1CA,EAAOsV,EAAM7Q,UAET6Q,EAAM/P,SAEN+P,EAAMiB,kBASlB5W,kBAMI,IAAI2V,EACAtV,EAEJ,IAPAD,KAAK0W,QAAQC,QAEb3W,KAAK4W,mBAKArB,EAAQvV,KAAKgV,YAAaO,EAAOA,EAAQtV,EAI1C,GAFAA,EAAOsV,EAAM7Q,UAER6Q,EAAM/P,SAAY+P,EAAMsB,WAQ7B,GAHAtB,EAAMuB,kBAGFvB,EAAMwB,MACV,CACI,MAAMC,EAAezB,EAAMwB,MAAmBC,YAAczB,EAAMwB,MAElEC,EAAWF,kBACX9W,KAAK0W,QAAQO,cAAc1B,EAAMmB,QAASM,EAAWN,cAEhDnB,EAAM2B,WAEXlX,KAAK0W,QAAQS,cAAc5B,EAAMmB,QAASnB,EAAM2B,YAIhDlX,KAAK0W,QAAQU,UAAU7B,EAAMmB,SAIrC1W,KAAK0W,QAAQW,SAAWrX,KAAK2V,UAM1B/V,eAAe0X,EAAkBC,GAAqB,GAGzD,MAAMC,EAASC,EAAAA,cAAcC,UAAUC,eAAeC,KAAK5X,KAAMsX,GAEjE,IAAKC,EACL,CACI,IAAIhC,EACAtV,EAEJ,IAAKsV,EAAQvV,KAAKgV,YAAaO,EAAOA,EAAQtV,EAE1CA,EAAOsV,EAAM7Q,UAET6Q,EAAM/P,SAEN+P,EAAMiB,kBAKlB,OAAOgB,EAMX5X,OAAOiY,GAGH,GAAK7X,KAAKwF,WAAWxF,KAAKyW,YAAc,IAAMzW,KAAK6W,WAMnD,GAAI7W,KAAK+W,OAAU/W,KAAK8X,SAAW9X,KAAK8X,QAAQpX,OAE5CV,KAAK+X,eAAeF,OAGxB,CAGI,IAAItC,EACAtV,EAGJ,IANAD,KAAKgY,QAAQH,GAMRtC,EAAQvV,KAAKgV,YAAaO,EAAOA,EAAQtV,EAE1CA,EAAOsV,EAAM7Q,UACb6Q,EAAM0C,OAAOJ,IAQfjY,eAAeiY,GAErBA,EAASK,MAAMC,QAEf,MAAML,EAAU9X,KAAK8X,QACfM,EAAOpY,KAAK+W,MAMlB,GAAIe,EACJ,CACS9X,KAAKqY,kBAENrY,KAAKqY,gBAAkB,IAG3BrY,KAAKqY,gBAAgB3X,OAAS,EAE9B,IAAK,IAAIC,EAAI,EAAGA,EAAImX,EAAQpX,OAAQC,IAE5BmX,EAAQnX,GAAG2X,SAEXtY,KAAKqY,gBAAgB5O,KAAKqO,EAAQnX,IAItCX,KAAKqY,gBAAgB3X,QAErBmX,EAASrO,OAAOC,KAAKzJ,KAAMA,KAAKqY,iBAYxC,IAAI9C,EACAtV,EAGJ,IAZImY,GAEAP,EAASO,KAAK3O,KAAKzJ,KAAMA,KAAK+W,OAIlC/W,KAAKgY,QAAQH,GAMRtC,EAAQvV,KAAKgV,YAAaO,EAAOA,EAAQtV,EAE1CA,EAAOsV,EAAM7Q,UACb6Q,EAAM0C,OAAOJ,GAGjBA,EAASK,MAAMC,QAEXC,GAEAP,EAASO,KAAKG,IAAIvY,MAGlB8X,GAAW9X,KAAKqY,iBAAmBrY,KAAKqY,gBAAgB3X,QAExDmX,EAASrO,OAAO+O,MAQxB3Y,aAAaiY,GAGT,IAAK7X,KAAKwF,SAAWxF,KAAKyW,YAAc,IAAMzW,KAAK6W,WAE/C,OAUJ,IAAItB,EACAtV,EAEJ,IAVID,KAAK+W,OAELc,EAASW,YAAYC,SAASzY,KAAK+W,OAGtC/W,KAAa0Y,cAAcb,GAKvBtC,EAAQvV,KAAKgV,YAAaO,EAAOA,EAAQtV,EAE1CA,EAAOsV,EAAM7Q,UACZ6Q,EAAcoD,aAAad,GAG5B7X,KAAK+W,OAELc,EAASW,YAAYI,QAAQf,8GC7sBXlT,EAAyCkU,+CAGnE,GAAI,cAAelU,EAEf,OAAOA,EAGX,MAAMsI,EAAuB,CACzBtE,SAAUhE,EAAOgE,SACjB5I,KAAM4E,EAAO5E,KACbiH,iBAAkBrC,EAAOqC,iBACzByB,UAAW9D,EAAO8D,UAClB9B,YAAahC,EAAOgC,YACpBE,gBAAiBlC,EAAOkC,gBACxBD,aAAcjC,EAAOiC,aACrBU,UAAW3C,EAAO2C,UAClByB,IAAKpE,EAAOoE,IACZE,KAAMtE,EAAOsE,KACbE,WAAYxE,EAAOwE,WACnBC,UAAW,IAIf,GAAIzE,EAAOhC,MAEP,GAAI,UAAWgC,EAAOhC,MAElB,GAAIgC,EAAOhC,MAAM/B,QAAU+D,EAAOhC,MAAM9B,IAET,IAAvB8D,EAAOhC,MAAM/B,OAEbqM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,cACN7D,OAAQ,CAAEhC,MAAOgC,EAAOhC,MAAM/B,aAK1C,CACI,MAAMN,EAA0B,CAC5BA,KAAM,CACF,CAAER,KAAM,EAAGD,MAAO8E,EAAOhC,MAAM/B,OAC/B,CAAEd,KAAM,EAAGD,MAAO8E,EAAOhC,MAAM9B,OAIvCoM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,QACN7D,OAAQ,CAAEhC,MAAOrC,UAIS,IAA7BqE,EAAOhC,MAAMrC,KAAKI,OAEY,IAA/BiE,EAAOhC,MAAMrC,KAAK,GAAGT,OAErBoN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,cACN7D,OAAQ,CAAEhC,MAAOgC,EAAOhC,MAAMrC,KAAK,GAAGT,SAM9CoN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,QACN7D,OAAQ,CAAEhC,MAAOgC,EAAOhC,SAMpC,GAAIgC,EAAOmU,eAAiBnU,EAAOmU,aAAajX,GAAK8C,EAAOmU,aAAahX,GACzE,CACI,IAAIwL,EACAC,EAEA,UAAW5I,EAAOgJ,OAElBL,EAAW3I,EAAOgJ,MAAM/M,OAA4C,QAAnC8M,EAAA/I,EAAOgJ,MAAMoL,8BAAsB,IAAArL,EAAAA,EAAI,GACxEH,EAAW5I,EAAOgJ,MAAM/M,QAIxB0M,EAAW3I,EAAOgJ,MAAMrN,KAAK,GAAGT,OAA2D,QAAlDmZ,EAACrU,EAA2BoU,8BAAsB,IAAAC,EAAAA,EAAI,GAC/FzL,EAAW5I,EAAOgJ,MAAMrN,KAAK,GAAGT,OAGpCoN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,mBACN7D,OAAQ,CACJ6I,MAAO7I,EAAOmU,aACdxL,SAAAA,EACAC,SAAAA,EACApF,QAASxD,EAAOsU,WAChBxL,SAAU9I,EAAO8I,iBAKxB,GAAoB,QAAhByL,EAAAvU,EAAOwU,iBAAS,IAAAD,OAAA,EAAAA,EAAE7H,KAC3B,CACI,IAAI/Q,EACAyR,EAEA,UAAWpN,EAAOgJ,OAElBoE,EAA0C,QAAnCqH,EAAAzU,EAAOgJ,MAAMoL,8BAAsB,IAAAK,EAAAA,EAAI,EAG1C9Y,EAFAqE,EAAOgJ,MAAM/M,QAAU+D,EAAOgJ,MAAM9M,IAE7B,CACHP,KAAM,CAAC,CAAER,KAAM,EAAGD,MAAO8E,EAAOgJ,MAAM/M,SAKnC,CACHN,KAAM,CACF,CAAER,KAAM,EAAGD,MAAO8E,EAAOgJ,MAAM/M,OAC/B,CAAEd,KAAM,EAAGD,MAAO8E,EAAOgJ,MAAM9M,SAO3CP,EAAOqE,EAAOgJ,MACdoE,EAA0D,QAAlDsH,EAAC1U,EAA2BoU,8BAAsB,IAAAM,EAAAA,EAAI,GAGlEpM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,WACN7D,OAAQ,CACJ0M,KAAM1M,EAAOwU,UAAU9H,KACvB1D,MAAOrN,EACPqR,QAASI,UAOjB,GAAI,UAAWpN,EAAOgJ,MAElB,GAAIhJ,EAAOgJ,MAAM/M,QAAU+D,EAAOgJ,MAAM9M,IAEpCoM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,kBACN7D,OAAQ,CACJiE,IAAKjE,EAAOgJ,MAAM/M,OAA4C,QAAnC0Y,EAAA3U,EAAOgJ,MAAMoL,8BAAsB,IAAAO,EAAAA,EAAI,GAClEzQ,IAAKlE,EAAOgJ,MAAM/M,aAK9B,CACI,MAAMN,EAA0B,CAC5BA,KAAM,CACF,CAAER,KAAM,EAAGD,MAAO8E,EAAOgJ,MAAM/M,OAC/B,CAAEd,KAAM,EAAGD,MAAO8E,EAAOgJ,MAAM9M,OAIvCoM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,YACN7D,OAAQ,CAAEgJ,MAAOrN,EAAMqR,QAAShN,EAAOgJ,MAAMoL,+BAInB,IAA7BpU,EAAOgJ,MAAMrN,KAAKI,OAEvBuM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,kBACN7D,OAAQ,CACJiE,IAAKjE,EAAOgJ,MAAMrN,KAAK,GAAGT,OAA2D,QAAlD0Z,EAAC5U,EAA2BoU,8BAAsB,IAAAQ,EAAAA,EAAI,GACzF1Q,IAAKlE,EAAOgJ,MAAMrN,KAAK,GAAGT,SAMlCoN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,YACN7D,OAAQ,CAAEgJ,MAAOhJ,EAAOgJ,MAAOgE,QAA4D,QAAlD6H,EAAC7U,EAA2BoU,8BAAsB,IAAAS,EAAAA,EAAI,KAM3G,GAAI7U,EAAOW,MAEP,GAAI,UAAWX,EAAOW,MACtB,CACI,MAAMyM,EAA0C,QAAnC0H,EAAA9U,EAAOW,MAAMoU,8BAAsB,IAAAD,EAAAA,EAAI,EAEpD,GAAI9U,EAAOW,MAAM1E,QAAU+D,EAAOW,MAAMzE,IAEpCoM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,cACN7D,OAAQ,CACJiE,IAAKjE,EAAOW,MAAM1E,MAAQmR,EAC1BlJ,IAAKlE,EAAOW,MAAM1E,aAK9B,CACI,MAAMN,EAA0B,CAC5BA,KAAM,CACF,CAAER,KAAM,EAAGD,MAAO8E,EAAOW,MAAM1E,OAC/B,CAAEd,KAAM,EAAGD,MAAO8E,EAAOW,MAAMzE,OAIvCoM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,QACN7D,OAAQ,CAAEW,MAAOhF,EAAMqR,QAASI,WAIvC,GAAiC,IAA7BpN,EAAOW,MAAMhF,KAAKI,OAC3B,CACI,MAAMqR,EAAyD,QAAlD4H,EAAChV,EAA2B+U,8BAAsB,IAAAC,EAAAA,EAAI,EAC7DrU,EAAQX,EAAOW,MAAMhF,KAAK,GAAGT,MAEnCoN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,cACN7D,OAAQ,CAAEiE,IAAKtD,EAAQyM,EAAMlJ,IAAKvD,UAKtC2H,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,QACN7D,OAAQ,CAAEW,MAAOX,EAAOW,MAAOqM,QAA2D,QAAlDiI,EAACjV,EAA2B+U,8BAAsB,IAAAE,EAAAA,EAAI,KAM1G,GAAIjV,EAAOlC,MAEP,GAAI,UAAWkC,EAAOlC,MAElB,GAAIkC,EAAOlC,MAAM7B,QAAU+D,EAAOlC,MAAM5B,IAET,WAAvB8D,EAAOlC,MAAM7B,OAEbqM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,cACN7D,OAAQ,CAAElC,MAAOkC,EAAOlC,MAAM7B,aAK1C,CACI,MAAMN,EAA0B,CAC5BA,KAAM,CACF,CAAER,KAAM,EAAGD,MAAO8E,EAAOlC,MAAM7B,OAC/B,CAAEd,KAAM,EAAGD,MAAO8E,EAAOlC,MAAM5B,OAIvCoM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,QACN7D,OAAQ,CAAElC,MAAOnC,UAIS,IAA7BqE,EAAOlC,MAAMnC,KAAKI,OAEY,WAA/BiE,EAAOlC,MAAMnC,KAAK,GAAGT,OAErBoN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,cACN7D,OAAQ,CAAElC,MAAOkC,EAAOlC,MAAMnC,KAAK,GAAGT,SAM9CoN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,QACN7D,OAAQ,CAAElC,MAAOkC,EAAOlC,SAiDpC,GA3CIkC,EAAOkV,uBAA4C,QAApBC,EAAAnV,EAAOoV,qBAAa,IAAAD,OAAA,EAAAA,EAAElR,MAAOjE,EAAOoV,cAAclR,IAEjFoE,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,WACN7D,OAAQ,CACJ6I,MAAO7I,EAAOkV,sBAAwB,EACtCxH,UAA8B,QAApB2H,EAAArV,EAAOoV,qBAAa,IAAAC,OAAA,EAAAA,EAAEpR,MAAO,EACvC6E,UAA8B,QAApBwM,EAAAtV,EAAOoV,qBAAa,IAAAE,OAAA,EAAAA,EAAEpR,MAAO,EACvCyE,UAA8B,QAApB4M,EAAAvV,EAAOwV,qBAAa,IAAAD,OAAA,EAAAA,EAAEtR,MAAO,EACvC2E,UAA8B,QAApB6M,EAAAzV,EAAOwV,qBAAa,IAAAC,OAAA,EAAAA,EAAEvR,MAAO,OAItB,QAApBwR,EAAA1V,EAAOwV,qBAAa,IAAAE,OAAA,EAAAA,EAAEzR,OAA2B,QAApB0R,EAAA3V,EAAOwV,qBAAa,IAAAG,OAAA,EAAAA,EAAEzR,OAExDoE,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,iBACN7D,OAAQ,CACJiE,KAAyB,QAApB2R,EAAA5V,EAAOwV,qBAAa,IAAAI,OAAA,EAAAA,EAAE3R,MAAO,EAClCC,KAAyB,QAApB2R,EAAA7V,EAAOwV,qBAAa,IAAAK,OAAA,EAAAA,EAAE3R,MAAO,KAI1ClE,EAAOsU,YAEPhM,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,aACN7D,OAAQ,KAKZA,EAAO4L,WAAkC,WAArB5L,EAAO4L,WAE3BtD,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,YACN7D,OAAQ,CACJ4L,UAAW5L,EAAO4L,aAM1BhE,MAAMC,QAAQqM,IAA0B,iBAAXA,EAAI,IAAmB,cAAeA,EAAI,GAC3E,CACI,IAAK,IAAIlY,EAAI,EAAGA,EAAIkY,EAAInY,SAAUC,EAEL,cAArBkY,EAAIlY,GAAG+O,YAEPmJ,EAAIlY,GAAG+O,WAAa,GAG5BzC,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,iBACN7D,OAAQ,CACJ6K,MAAOqJ,SAIK,iBAARA,GAAoB,cAAeA,GAEzB,cAAlBA,EAAInJ,YAEJmJ,EAAInJ,WAAa,GAErBzC,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,iBACN7D,OAAQ,CACJ8K,KAAMoJ,MAKTlU,EAAO8V,YAAclO,MAAMC,QAAQqM,GAExC5L,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,iBACN7D,OAAQ,CACJuK,SAAU2J,KAKbtM,MAAMC,QAAQqM,GAEnB5L,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,gBACN7D,OAAQ,CACJuK,SAAU2J,KAOlB5L,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,gBACN7D,OAAQ,CACJ2K,QAASuJ,KAMrB,GAAyB,UAArBlU,EAAO+V,UAEPzN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,aACN7D,OAAQ,CACJ/D,MAAO+D,EAAOgW,YAAc,EAC5BlK,QAAS9L,EAAOiW,gBAEhBlK,SAAU,UAKjB,GAAyB,UAArB/L,EAAO+V,UAEZzN,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,aACN7D,OAAQ,SAKhB,CACI,IAAIsO,EAEqB,SAArBtO,EAAO+V,UAEPzH,EAAQ,CACJzK,KAAM,QACNpI,KAAM,CACFyB,EAAG8C,EAAOkW,YAAYhZ,EACtBC,EAAG6C,EAAOkW,YAAY/Y,EACtBmK,OAAQtH,EAAOkW,YAAY5Y,EAC3BiK,YAAavH,EAAOkW,YAAYC,KAChC3O,gBAAgB,IAIE,WAArBxH,EAAO+V,UAEZzH,EAAQ,CACJzK,KAAM,QACNpI,KAAM,CACFyB,EAAG8C,EAAOkW,YAAYhZ,EACtBC,EAAG6C,EAAOkW,YAAY/Y,EACtBmK,OAAQtH,EAAOkW,YAAY5Y,EAC3BiK,YAAa,EACbC,gBAAgB,IAIE,SAArBxH,EAAO+V,UAEZzH,EAAQ,CACJzK,KAAM,OACNpI,KAAMuE,EAAOoW,WAGS,mBAArBpW,EAAO+V,YAEZzH,EAAQ,CACJzK,KAAM,iBACNpI,KAAMuE,EAAOqW,eAGrB/N,EAAI7D,UAAUK,KAAK,CACfjB,KAAM,aACN7D,OAAQsO,IAIhB,OAAOhG","file":"dist/particle-emitter.min.js.map","sourcesContent":["import { generateEase, hexToRGB, EaseSegment, SimpleEase, Color } from './ParticleUtils';\nimport { BasicTweenable } from './EmitterConfig';\n\n/**\n * A single step of a ValueList.\n */\nexport interface ValueStep<T> {\n    /**\n     * The color or number to use at this step.\n     */\n    value: T;\n    /**\n     * The percentage time of the particle's lifespan that this step happens at.\n     * Values are between 0 and 1, inclusive.\n     */\n    time: number;\n}\n\n/**\n * Configuration for an interpolated or stepped list of numeric or color particle values.\n */\nexport interface ValueList<T> {\n    /**\n     * The ordered list of values.\n     */\n    list: ValueStep<T>[];\n    /**\n     * If the list is stepped. Stepped lists don't determine any in-between values, instead sticking with each value\n     * until its time runs out.\n     */\n    isStepped?: boolean;\n    /**\n     * Easing that should be applied to this list, in order to alter how quickly the steps progress.\n     */\n    ease?: SimpleEase|EaseSegment[];\n}\n/**\n * A single node in a PropertyList.\n */\nexport class PropertyNode<V>\n{\n    /**\n     * Value for the node.\n     */\n    public value: V;\n    /**\n     * Time value for the node. Between 0-1.\n     */\n    public time: number;\n    /**\n     * The next node in line.\n     */\n    public next: PropertyNode<V>;\n    /**\n     * If this is the first node in the list, controls if the entire list is stepped or not.\n     */\n    public isStepped: boolean;\n    public ease: SimpleEase;\n\n    /**\n     * @param value The value for this node\n     * @param time The time for this node, between 0-1\n     * @param [ease] Custom ease for this list. Only relevant for the first node.\n     */\n    constructor(value: V, time: number, ease?: SimpleEase|EaseSegment[])\n    {\n        this.value = value;\n        this.time = time;\n        this.next = null;\n        this.isStepped = false;\n        if (ease)\n        {\n            this.ease = typeof ease === 'function' ? ease : generateEase(ease);\n        }\n        else\n        {\n            this.ease = null;\n        }\n    }\n\n    /**\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\n     * {start, end}.\n     * @param data The data for the list.\n     * @param data.list The array of value and time objects.\n     * @param data.isStepped If the list is stepped rather than interpolated.\n     * @param data.ease Custom ease for this list.\n     * @return The first node in the list\n     */\n    // eslint-disable-next-line max-len\n    public static createList<T extends(string|number)>(data: ValueList<T>|BasicTweenable<T>): PropertyNode<T extends string ? Color : T>\n    {\n        if ('list' in data)\n        {\n            const array = data.list;\n            let node;\n            const { value, time } = array[0];\n\n            // eslint-disable-next-line max-len\n            const first = node = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time, data.ease);\n\n            // only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\n            if (array.length > 2 || (array.length === 2 && array[1].value !== value))\n            {\n                for (let i = 1; i < array.length; ++i)\n                {\n                    const { value, time } = array[i];\n\n                    node.next = new PropertyNode(typeof value === 'string' ? hexToRGB(value) : value, time);\n                    node = node.next;\n                }\n            }\n            first.isStepped = !!data.isStepped;\n\n            return first as PropertyNode<T extends string ? Color : T>;\n        }\n\n        // Handle deprecated version here\n        const start = new PropertyNode(typeof data.start === 'string' ? hexToRGB(data.start) : data.start, 0);\n        // only set up a next value if it is different from the starting value\n\n        if (data.end !== data.start)\n        {\n            start.next = new PropertyNode(typeof data.end === 'string' ? hexToRGB(data.end) : data.end, 1);\n        }\n\n        return start as PropertyNode<T extends string ? Color : T>;\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { IPointData } from '@pixi/math';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { PropertyNode, ValueStep } from './PropertyNode';\n\n/**\n * The method used by behaviors to fetch textures. Defaults to Texture.from.\n */\n// get Texture.from(), only supports V5 and V6 with individual packages\n// eslint-disable-next-line prefer-const\nexport let GetTextureFromString:(d:string) => Texture = Texture.from;\n\n/**\n * A color value, split apart for interpolation.\n */\nexport interface Color {\n    r: number;\n    g: number;\n    b: number;\n    a?: number;\n}\n\nexport interface EaseSegment {\n    cp: number;\n    s: number;\n    e: number;\n}\n\n/**\n * The basic easing function used. Takes in a value between 0-1, and outputs another value between 0-1.\n * For example, a basic quadratic in ease would be `(time) => time * time`\n */\nexport type SimpleEase = (time: number) => number;\n\n/**\n * If errors and warnings should be logged within the library.\n */\nexport const verbose = false;\n\nexport const DEG_TO_RADS = Math.PI / 180;\n\n/**\n * Rotates a point by a given angle.\n * @param angle The angle to rotate by in radians\n * @param p The point to rotate around 0,0.\n */\nexport function rotatePoint(angle: number, p: IPointData): void\n{\n    if (!angle) return;\n\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n    const xnew = (p.x * c) - (p.y * s);\n    const ynew = (p.x * s) + (p.y * c);\n\n    p.x = xnew;\n    p.y = ynew;\n}\n\n/**\n * Combines separate color components (0-255) into a single uint color.\n * @param r The red value of the color\n * @param g The green value of the color\n * @param b The blue value of the color\n * @return The color in the form of 0xRRGGBB\n */\nexport function combineRGBComponents(r: number, g: number, b: number/* , a*/): number\n{\n    return /* a << 24 |*/ (r << 16) | (g << 8) | b;\n}\n\n/**\n * Returns the length (or magnitude) of this point.\n * @param point The point to measure length\n * @return The length of this point.\n */\nexport function length(point: IPointData): number\n{\n    return Math.sqrt((point.x * point.x) + (point.y * point.y));\n}\n\n/**\n * Reduces the point to a length of 1.\n * @param point The point to normalize\n */\nexport function normalize(point: IPointData): void\n{\n    const oneOverLen = 1 / length(point);\n\n    point.x *= oneOverLen;\n    point.y *= oneOverLen;\n}\n\n/**\n * Multiplies the x and y values of this point by a value.\n * @param point The point to scaleBy\n * @param value The value to scale by.\n */\nexport function scaleBy(point: IPointData, value: number): void\n{\n    point.x *= value;\n    point.y *= value;\n}\n\n/**\n * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\n * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\n * {r, g, b, (a)}.\n * @param color The input color string.\n * @param output An object to put the output in. If omitted, a new object is created.\n * @return The object with r, g, and b properties, possibly with an a property.\n */\nexport function hexToRGB(color: string, output?: Color): Color\n{\n    if (!output)\n    {\n        output = {} as Color;\n    }\n    if (color.charAt(0) === '#')\n    {\n        color = color.substr(1);\n    }\n    else if (color.indexOf('0x') === 0)\n    {\n        color = color.substr(2);\n    }\n    let alpha;\n\n    if (color.length === 8)\n    {\n        alpha = color.substr(0, 2);\n        color = color.substr(2);\n    }\n    output.r = parseInt(color.substr(0, 2), 16);// Red\n    output.g = parseInt(color.substr(2, 2), 16);// Green\n    output.b = parseInt(color.substr(4, 2), 16);// Blue\n    if (alpha)\n    {\n        output.a = parseInt(alpha, 16);\n    }\n\n    return output;\n}\n\n/**\n * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\n * by the related tool at http://www.greensock.com/customease/.\n * @param segments An array of segments, as created by\n * http://www.greensock.com/customease/.\n * @return A function that calculates the percentage of change at\n *                    a given point in time (0-1 inclusive).\n */\nexport function generateEase(segments: EaseSegment[]): SimpleEase\n{\n    const qty = segments.length;\n    const oneOverQty = 1 / qty;\n    /*\n        * Calculates the percentage of change at a given point in time (0-1 inclusive).\n        * @param {Number} time The time of the ease, 0-1 inclusive.\n        * @return {Number} The percentage of the change, 0-1 inclusive (unless your\n        *                  ease goes outside those bounds).\n        */\n\n    // eslint-disable-next-line func-names\n    return function (time: number): number\n    {\n        const i = (qty * time) | 0;// do a quick floor operation\n\n        const t = (time - (i * oneOverQty)) * qty;\n        const s = segments[i] || segments[qty - 1];\n\n        return (s.s + (t * ((2 * (1 - t) * (s.cp - s.s)) + (t * (s.e - s.s)))));\n    };\n}\n\n/**\n * Gets a blend mode, ensuring that it is valid.\n * @param name The name of the blend mode to get.\n * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\n */\nexport function getBlendMode(name: string): number\n{\n    if (!name) return BLEND_MODES.NORMAL;\n    name = name.toUpperCase().replace(/ /g, '_');\n\n    return (BLEND_MODES as any)[name] || BLEND_MODES.NORMAL;\n}\n\n/**\n * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\n * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\n * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\n * @param list The list of data to convert.\n * @param [numSteps=10] The number of steps to use.\n * @return The blend mode as specified in the PIXI.blendModes enumeration.\n */\nexport function createSteppedGradient(list: ValueStep<string>[], numSteps = 10): PropertyNode<Color>\n{\n    if (typeof numSteps !== 'number' || numSteps <= 0)\n    {\n        numSteps = 10;\n    }\n    const first = new PropertyNode<Color>(hexToRGB(list[0].value), list[0].time);\n\n    first.isStepped = true;\n    let currentNode = first;\n    let current = list[0];\n    let nextIndex = 1;\n    let next = list[nextIndex];\n\n    for (let i = 1; i < numSteps; ++i)\n    {\n        let lerp = i / numSteps;\n        // ensure we are on the right segment, if multiple\n\n        while (lerp > next.time)\n        {\n            current = next;\n            next = list[++nextIndex];\n        }\n        // convert the lerp value to the segment range\n        lerp = (lerp - current.time) / (next.time - current.time);\n        const curVal = hexToRGB(current.value);\n        const nextVal = hexToRGB(next.value);\n        const output: Color = {\n            r: ((nextVal.r - curVal.r) * lerp) + curVal.r,\n            g: ((nextVal.g - curVal.g) * lerp) + curVal.g,\n            b: ((nextVal.b - curVal.b) * lerp) + curVal.b,\n        };\n\n        currentNode.next = new PropertyNode(output, i / numSteps);\n        currentNode = currentNode.next;\n    }\n\n    // we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\n    // the particle has died of old age\n    return first;\n}\n","import { Particle } from '../Particle';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * All behaviors instances must implement this interface, and the class must match the\n * {@link IEmitterBehaviorClass} interface. All behaviors must have an order property and\n * `initParticles` method. Implementing the `updateParticle` or `recycleParticle` methods is optional.\n */\nexport interface IEmitterBehavior\n{\n    /**\n     * Order in which the behavior will be handled. Lower numbers are handled earlier, with an order of 0 getting\n     * special treatment before the Emitter's transformation is applied.\n     */\n    order: number;\n    /**\n     * Called to initialize a wave of particles, with a reference to the first particle in the linked list.\n     * @param first The first (maybe only) particle in a newly spawned wave of particles.\n     */\n    initParticles(first: Particle): void;\n    /**\n     * Updates a single particle for a given period of time elapsed. Return `true` to recycle the particle.\n     * @param particle The particle to update.\n     * @param deltaSec The time to advance the particle by in seconds.\n     */\n    updateParticle?(particle: Particle, deltaSec: number): void|boolean;\n    /**\n     * A hook for when a particle is recycled.\n     * @param particle The particle that was just recycled.\n     * @param natural `true` if the reycling was due to natural lifecycle, `false` if it was due to emitter cleanup.\n     */\n    recycleParticle?(particle: Particle, natural: boolean): void;\n}\n\n/**\n * All behavior classes must match this interface. The instances need to implement the {@link IEmitterBehavior} interface.\n */\nexport interface IEmitterBehaviorClass\n{\n    /**\n     * The unique type name that the behavior is registered under.\n     */\n    type: string;\n    /**\n     * Configuration data for an editor to display this behavior. Does not need to exist in production code.\n     */\n    editorConfig?: BehaviorEditorConfig;\n    /**\n     * The behavior constructor itself.\n     * @param config The config for the behavior, which should match its defined specifications.\n     */\n    new (config: any): IEmitterBehavior;\n}\n\n/**\n * Standard behavior order values, specifying when/how they are used. Other numeric values can be used,\n * but only the Spawn value will be handled in a special way. All other values will be sorted numerically.\n * Behaviors with the same value will not be given any specific sort order, as they are assumed to not\n * interfere with each other.\n */\nexport enum BehaviorOrder\n{\n    /**\n     * Spawn - initial placement and/or rotation. This happens before rotation/translation due to\n     * emitter rotation/position is applied.\n     */\n    Spawn = 0,\n    /**\n     * Normal priority, for things that don't matter when they are applied.\n     */\n    Normal = 2,\n    /**\n     * Delayed priority, for things that need to read other values in order to act correctly.\n     */\n    Late = 5,\n}\n","import { Emitter } from './Emitter';\nimport { LinkedListChild } from './LinkedListContainer';\nimport { Sprite } from '@pixi/sprite';\n\n/**\n * An individual particle image. You shouldn't have to deal with these.\n */\nexport class Particle extends Sprite implements LinkedListChild\n{\n    /**\n     * The emitter that controls this particle.\n     */\n    public emitter: Emitter;\n    /**\n     * The maximum lifetime of this particle, in seconds.\n     */\n    public maxLife: number;\n    /**\n     * The current age of the particle, in seconds.\n     */\n    public age: number;\n    /**\n     * The current age of the particle as a normalized value between 0 and 1.\n     */\n    public agePercent: number;\n    /**\n     * One divided by the max life of the particle, saved for slightly faster math.\n     */\n    public oneOverLife: number;\n    /**\n     * Reference to the next particle in the list.\n     */\n    public next: Particle;\n\n    /**\n     * Reference to the previous particle in the list.\n     */\n    public prev: Particle;\n\n    public prevChild: LinkedListChild;\n    public nextChild: LinkedListChild;\n\n    /**\n     * Static per-particle configuration for behaviors to use. Is not cleared when recycling.\n     */\n    public config: {[key: string]: any};\n\n    /**\n     * @param emitter The emitter that controls this particle.\n     */\n    constructor(emitter: Emitter)\n    {\n        // start off the sprite with a blank texture, since we are going to replace it\n        // later when the particle is initialized.\n        super();\n        // initialize LinkedListChild props so they are included in underlying JS class definition\n        this.prevChild = this.nextChild = null;\n\n        this.emitter = emitter;\n        this.config = {};\n        // particles should be centered\n        this.anchor.x = this.anchor.y = 0.5;\n        this.maxLife = 0;\n        this.age = 0;\n        this.agePercent = 0;\n        this.oneOverLife = 0;\n        this.next = null;\n        this.prev = null;\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.init = this.init;\n        this.kill = this.kill;\n    }\n\n    /**\n     * Initializes the particle for use, based on the properties that have to\n     * have been set already on the particle.\n     */\n    public init(maxLife: number): void\n    {\n        this.maxLife = maxLife;\n        // reset the age\n        this.age = this.agePercent = 0;\n        // reset the sprite props\n        this.rotation = 0;\n        this.position.x = this.position.y = 0;\n        this.scale.x = this.scale.y = 1;\n        this.tint = 0xffffff;\n        this.alpha = 1;\n        // save our lerp helper\n        this.oneOverLife = 1 / this.maxLife;\n\n        // ensure visibility\n        this.visible = true;\n    }\n\n    /**\n     * Kills the particle, removing it from the display list\n     * and telling the emitter to recycle it.\n     */\n    public kill(): void\n    {\n        this.emitter.recycle(this);\n    }\n\n    /**\n     * Destroys the particle, removing references and preventing future use.\n     */\n    public destroy(): void\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.emitter = this.next = this.prev = null;\n        super.destroy();\n    }\n}\n","import { generateEase, rotatePoint, SimpleEase } from './ParticleUtils';\nimport { Particle } from './Particle';\nimport { EmitterConfigV3 } from './EmitterConfig';\nimport { Container } from '@pixi/display';\nimport { settings } from '@pixi/settings';\nimport { Point } from '@pixi/math';\nimport { Ticker } from '@pixi/ticker';\nimport { BehaviorOrder, IEmitterBehavior, IEmitterBehaviorClass } from './behaviors/Behaviors';\n// get the shared ticker, only supports V5 and V6 with individual packages\n/**\n * @hidden\n */\nconst ticker = Ticker.shared;\n\n/**\n * Key used in sorted order to determine when to set particle position from the emitter position\n * and rotation.\n */\nconst PositionParticle = Symbol('Position particle per emitter position');\n\n/**\n * A particle emitter.\n */\nexport class Emitter\n{\n    private static knownBehaviors: {[key: string]: IEmitterBehaviorClass} = {};\n\n    /**\n     * Registers a new behavior, so that it will be recognized when initializing emitters.\n     * Behaviors registered later with duplicate types will override older ones, although there is no limit on\n     * the allowed types.\n     * @param constructor The behavior class to register.\n     */\n    public static registerBehavior(constructor: IEmitterBehaviorClass): void\n    {\n        Emitter.knownBehaviors[constructor.type] = constructor;\n    }\n\n    /**\n     * Active initialization behaviors for this emitter.\n     */\n    protected initBehaviors: (IEmitterBehavior | typeof PositionParticle)[];\n    /**\n     * Active update behaviors for this emitter.\n     */\n    protected updateBehaviors: IEmitterBehavior[];\n    /**\n     * Active recycle behaviors for this emitter.\n     */\n    protected recycleBehaviors: IEmitterBehavior[];\n    // properties for individual particles\n    /**\n     * The minimum lifetime for a particle, in seconds.\n     */\n    public minLifetime: number;\n    /**\n     * The maximum lifetime for a particle, in seconds.\n     */\n    public maxLifetime: number;\n    /**\n     * An easing function for nonlinear interpolation of values. Accepts a single\n     * parameter of time as a value from 0-1, inclusive. Expected outputs are values\n     * from 0-1, inclusive.\n     */\n    public customEase: SimpleEase;\n    // properties for spawning particles\n    /**\n     * Time between particle spawns in seconds.\n     */\n    protected _frequency: number;\n    /**\n     * Chance that a particle will be spawned on each opportunity to spawn one.\n     * 0 is 0%, 1 is 100%.\n     */\n    public spawnChance: number;\n    /**\n     * Maximum number of particles to keep alive at a time. If this limit\n     * is reached, no more particles will spawn until some have died.\n     */\n    public maxParticles: number;\n    /**\n     * The amount of time in seconds to emit for before setting emit to false.\n     * A value of -1 is an unlimited amount of time.\n     */\n    public emitterLifetime: number;\n    /**\n     * Position at which to spawn particles, relative to the emitter's owner's origin.\n     * For example, the flames of a rocket travelling right might have a spawnPos\n     * of {x:-50, y:0}.\n     * to spawn at the rear of the rocket.\n     * To change this, use updateSpawnPos().\n     */\n    public spawnPos: Point;\n    /**\n     * Number of particles to spawn time that the frequency allows for particles to spawn.\n     */\n    public particlesPerWave: number;\n    /**\n     * Rotation of the emitter or emitter's owner in degrees. This is added to\n     * the calculated spawn angle.\n     * To change this, use rotate().\n     */\n    protected rotation: number;\n    /**\n     * The world position of the emitter's owner, to add spawnPos to when\n     * spawning particles. To change this, use updateOwnerPos().\n     */\n    protected ownerPos: Point;\n    /**\n     * The origin + spawnPos in the previous update, so that the spawn position\n     * can be interpolated to space out particles better.\n     */\n    protected _prevEmitterPos: Point;\n    /**\n     * If _prevEmitterPos is valid, to prevent interpolation on the first update\n     */\n    protected _prevPosIsValid: boolean;\n    /**\n     * If either ownerPos or spawnPos has changed since the previous update.\n     */\n    protected _posChanged: boolean;\n    /**\n     * The container to add particles to.\n     */\n    protected _parent: Container;\n    /**\n     * If particles should be added at the back of the display list instead of the front.\n     */\n    public addAtBack: boolean;\n    /**\n     * The current number of active particles.\n     */\n    public particleCount: number;\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    protected _emit: boolean;\n    /**\n     * The timer for when to spawn particles in seconds, where numbers less\n     * than 0 mean that particles should be spawned.\n     */\n    protected _spawnTimer: number;\n    /**\n     * The life of the emitter in seconds.\n     */\n    protected _emitterLife: number;\n    /**\n     * The particles that are active and on the display list. This is the first particle in a\n     * linked list.\n     */\n    protected _activeParticlesFirst: Particle;\n    /**\n     * The particles that are active and on the display list. This is the last particle in a\n     * linked list.\n     */\n    protected _activeParticlesLast: Particle;\n    /**\n     * The particles that are not currently being used. This is the first particle in a\n     * linked list.\n     */\n    protected _poolFirst: Particle;\n    /**\n     * The original config object that this emitter was initialized with.\n     */\n    protected _origConfig: any;\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    protected _autoUpdate: boolean;\n    /**\n     * If the emitter should destroy itself when all particles have died out. This is set by\n     * playOnceAndDestroy();\n     */\n    protected _destroyWhenComplete: boolean;\n    /**\n     * A callback for when all particles have died out. This is set by\n     * playOnceAndDestroy() or playOnce();\n     */\n    protected _completeCallback: () => void;\n\n    /**\n     * @param particleParent The container to add the particles to.\n     * @param particleImages A texture or array of textures to use\n     *                       for the particles. Strings will be turned\n     *                       into textures via Texture.from().\n     * @param config A configuration object containing settings for the emitter.\n     * @param config.emit If config.emit is explicitly passed as false, the\n     *                    Emitter will start disabled.\n     * @param config.autoUpdate If config.autoUpdate is explicitly passed as\n     *                          true, the Emitter will automatically call\n     *                          update via the PIXI shared ticker.\n     */\n    constructor(particleParent: Container, config: EmitterConfigV3)\n    {\n        this.initBehaviors = [];\n        this.updateBehaviors = [];\n        this.recycleBehaviors = [];\n        // properties for individual particles\n        this.minLifetime = 0;\n        this.maxLifetime = 0;\n        this.customEase = null;\n        // properties for spawning particles\n        this._frequency = 1;\n        this.spawnChance = 1;\n        this.maxParticles = 1000;\n        this.emitterLifetime = -1;\n        this.spawnPos = new Point();\n        this.particlesPerWave = 1;\n        // emitter properties\n        this.rotation = 0;\n        this.ownerPos = new Point();\n        this._prevEmitterPos = new Point();\n        this._prevPosIsValid = false;\n        this._posChanged = false;\n        this._parent = null;\n        this.addAtBack = false;\n        this.particleCount = 0;\n        this._emit = false;\n        this._spawnTimer = 0;\n        this._emitterLife = -1;\n        this._activeParticlesFirst = null;\n        this._activeParticlesLast = null;\n        this._poolFirst = null;\n        this._origConfig = null;\n        this._autoUpdate = false;\n        this._destroyWhenComplete = false;\n        this._completeCallback = null;\n\n        // set the initial parent\n        this.parent = particleParent;\n\n        if (config)\n        {\n            this.init(config);\n        }\n\n        // save often used functions on the instance instead of the prototype for better speed\n        this.recycle = this.recycle;\n        this.update = this.update;\n        this.rotate = this.rotate;\n        this.updateSpawnPos = this.updateSpawnPos;\n        this.updateOwnerPos = this.updateOwnerPos;\n    }\n\n    /**\n     * Time between particle spawns in seconds. If this value is not a number greater than 0,\n     * it will be set to 1 (particle per second) to prevent infinite loops.\n     */\n    public get frequency(): number { return this._frequency; }\n    public set frequency(value: number)\n    {\n        // do some error checking to prevent infinite loops\n        if (typeof value === 'number' && value > 0)\n        {\n            this._frequency = value;\n        }\n        else\n        {\n            this._frequency = 1;\n        }\n    }\n\n    /**\n    * The container to add particles to. Settings this will dump any active particles.\n    */\n    public get parent(): Container { return this._parent; }\n    public set parent(value: Container)\n    {\n        this.cleanup();\n        this._parent = value;\n    }\n\n    /**\n     * Sets up the emitter based on the config settings.\n     * @param config A configuration object containing settings for the emitter.\n     */\n    public init(config: EmitterConfigV3): void\n    {\n        if (!config)\n        {\n            return;\n        }\n        // clean up any existing particles\n        this.cleanup();\n\n        // store the original config and particle images, in case we need to re-initialize\n        // when the particle constructor is changed\n        this._origConfig = config;\n\n        // /////////////////////////\n        // Particle Properties    //\n        // /////////////////////////\n\n        // set up the lifetime\n        this.minLifetime = config.lifetime.min;\n        this.maxLifetime = config.lifetime.max;\n        // use the custom ease if provided\n        if (config.ease)\n        {\n            this.customEase = typeof config.ease === 'function'\n                ? config.ease : generateEase(config.ease);\n        }\n        else\n        {\n            this.customEase = null;\n        }\n        // ////////////////////////\n        // Emitter Properties    //\n        // ////////////////////////\n        // reset spawn type specific settings\n        this.particlesPerWave = 1;\n        if (config.particlesPerWave && config.particlesPerWave > 1)\n        {\n            this.particlesPerWave = config.particlesPerWave;\n        }\n        // set the spawning frequency\n        this.frequency = config.frequency;\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\n        // set the emitter lifetime\n        this.emitterLifetime = config.emitterLifetime || -1;\n        // set the max particles\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\n        // determine if we should add the particle at the back of the list or not\n        this.addAtBack = !!config.addAtBack;\n        // reset the emitter position and rotation variables\n        this.rotation = 0;\n        this.ownerPos.set(0);\n        if (config.pos)\n        {\n            this.spawnPos.copyFrom(config.pos);\n        }\n        else\n        {\n            this.spawnPos.set(0);\n        }\n\n        this._prevEmitterPos.copyFrom(this.spawnPos);\n        // previous emitter position is invalid and should not be used for interpolation\n        this._prevPosIsValid = false;\n        // start emitting\n        this._spawnTimer = 0;\n        this.emit = config.emit === undefined ? true : !!config.emit;\n        this.autoUpdate = !!config.autoUpdate;\n\n        // ////////////////////////\n        // Behaviors             //\n        // ////////////////////////\n        const behaviors: (IEmitterBehavior | typeof PositionParticle)[] = config.behaviors.map((data) =>\n        {\n            const constructor = Emitter.knownBehaviors[data.type];\n\n            if (!constructor)\n            {\n                console.error(`Unknown behavior: ${data.type}`);\n\n                return null;\n            }\n\n            return new constructor(data.config);\n        })\n            .filter((b) => !!b);\n\n        behaviors.push(PositionParticle);\n        behaviors.sort((a, b) =>\n        {\n            if (a === PositionParticle)\n            {\n                return (b as IEmitterBehavior).order === BehaviorOrder.Spawn ? 1 : -1;\n            }\n            else if (b === PositionParticle)\n            {\n                return (a as IEmitterBehavior).order === BehaviorOrder.Spawn ? -1 : 1;\n            }\n\n            return (a as IEmitterBehavior).order - (b as IEmitterBehavior).order;\n        });\n        this.initBehaviors = behaviors.slice();\n        this.updateBehaviors = behaviors.filter((b) => b !== PositionParticle && b.updateParticle) as IEmitterBehavior[];\n        this.recycleBehaviors = behaviors.filter((b) => b !== PositionParticle && b.recycleParticle) as IEmitterBehavior[];\n    }\n\n    /**\n     * Gets the instantiated behavior of the specified type, if it is present on this emitter.\n     * @param type The behavior type to find.\n     */\n    public getBehavior(type: string): IEmitterBehavior|null\n    {\n        // bail if we don't know about such an emitter\n        if (!Emitter.knownBehaviors[type]) return null;\n\n        // find one that is an instance of the specified type\n        return this.initBehaviors.find((b) => b instanceof Emitter.knownBehaviors[type]) as IEmitterBehavior || null;\n    }\n\n    /**\n     * Fills the pool with the specified number of particles, so that they don't have to be instantiated later.\n     * @param count The number of particles to create.\n     */\n    public fillPool(count: number): void\n    {\n        for (; count > 0; --count)\n        {\n            const p = new Particle(this);\n\n            p.next = this._poolFirst;\n            this._poolFirst = p;\n        }\n    }\n\n    /**\n     * Recycles an individual particle. For internal use only.\n     * @param particle The particle to recycle.\n     * @param fromCleanup If this is being called to manually clean up all particles.\n     * @internal\n     */\n    public recycle(particle: Particle, fromCleanup = false): void\n    {\n        for (let i = 0; i < this.recycleBehaviors.length; ++i)\n        {\n            this.recycleBehaviors[i].recycleParticle(particle, !fromCleanup);\n        }\n        if (particle.next)\n        {\n            particle.next.prev = particle.prev;\n        }\n        if (particle.prev)\n        {\n            particle.prev.next = particle.next;\n        }\n        if (particle === this._activeParticlesLast)\n        {\n            this._activeParticlesLast = particle.prev;\n        }\n        if (particle === this._activeParticlesFirst)\n        {\n            this._activeParticlesFirst = particle.next;\n        }\n        // add to pool\n        particle.prev = null;\n        particle.next = this._poolFirst;\n        this._poolFirst = particle;\n        // remove child from display, or make it invisible if it is in a ParticleContainer\n        if (particle.parent)\n        {\n            particle.parent.removeChild(particle);\n        }\n        // decrease count\n        --this.particleCount;\n    }\n\n    /**\n     * Sets the rotation of the emitter to a new value. This rotates the spawn position in addition\n     * to particle direction.\n     * @param newRot The new rotation, in degrees.\n     */\n    public rotate(newRot: number): void\n    {\n        if (this.rotation === newRot) return;\n        // caclulate the difference in rotation for rotating spawnPos\n        const diff = newRot - this.rotation;\n\n        this.rotation = newRot;\n        // rotate spawnPos\n        rotatePoint(diff, this.spawnPos);\n        // mark the position as having changed\n        this._posChanged = true;\n    }\n\n    /**\n     * Changes the spawn position of the emitter.\n     * @param x The new x value of the spawn position for the emitter.\n     * @param y The new y value of the spawn position for the emitter.\n     */\n    public updateSpawnPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.spawnPos.x = x;\n        this.spawnPos.y = y;\n    }\n\n    /**\n     * Changes the position of the emitter's owner. You should call this if you are adding\n     * particles to the world container that your emitter's owner is moving around in.\n     * @param x The new x value of the emitter's owner.\n     * @param y The new y value of the emitter's owner.\n     */\n    public updateOwnerPos(x: number, y: number): void\n    {\n        this._posChanged = true;\n        this.ownerPos.x = x;\n        this.ownerPos.y = y;\n    }\n\n    /**\n     * Prevents emitter position interpolation in the next update.\n     * This should be used if you made a major position change of your emitter's owner\n     * that was not normal movement.\n     */\n    public resetPositionTracking(): void\n    {\n        this._prevPosIsValid = false;\n    }\n\n    /**\n     * If particles should be emitted during update() calls. Setting this to false\n     * stops new particles from being created, but allows existing ones to die out.\n     */\n    public get emit(): boolean { return this._emit; }\n    public set emit(value: boolean)\n    {\n        this._emit = !!value;\n        this._emitterLife = this.emitterLifetime;\n    }\n\n    /**\n     * If the update function is called automatically from the shared ticker.\n     * Setting this to false requires calling the update function manually.\n     */\n    public get autoUpdate(): boolean { return this._autoUpdate; }\n    public set autoUpdate(value: boolean)\n    {\n        if (this._autoUpdate && !value)\n        {\n            ticker.remove(this.update, this);\n        }\n        else if (!this._autoUpdate && value)\n        {\n            ticker.add(this.update, this);\n        }\n        this._autoUpdate = !!value;\n    }\n\n    /**\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\n     * when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnceAndDestroy(callback?: () => void): void\n    {\n        this.autoUpdate = true;\n        this.emit = true;\n        this._destroyWhenComplete = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\n     * @param callback Callback for when emission is complete (all particles have died off)\n     */\n    public playOnce(callback?: () => void): void\n    {\n        this.emit = true;\n        this._completeCallback = callback;\n    }\n\n    /**\n     * Updates all particles spawned by this emitter and emits new ones.\n     * @param delta Time elapsed since the previous frame, in __seconds__.\n     */\n    public update(delta: number): void\n    {\n        if (this._autoUpdate)\n        {\n            delta = delta / settings.TARGET_FPMS / 1000;\n        }\n\n        // if we don't have a parent to add particles to, then don't do anything.\n        // this also works as a isDestroyed check\n        if (!this._parent) return;\n\n        // == update existing particles ==\n\n        // update all particle lifetimes before turning them over to behaviors\n        for (let particle = this._activeParticlesFirst, next; particle; particle = next)\n        {\n            // save next particle in case we recycle this one\n            next = particle.next;\n            // increase age\n            particle.age += delta;\n            // recycle particle if it is too old\n            if (particle.age > particle.maxLife || particle.age < 0)\n            {\n                this.recycle(particle);\n            }\n            else\n            {\n                // determine our interpolation value\n                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                // global ease affects all interpolation calculations\n                if (this.customEase)\n                {\n                    if (this.customEase.length === 4)\n                    {\n                        // the t, b, c, d parameters that some tween libraries use\n                        // (time, initial value, end value, duration)\n                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                    }\n                    else\n                    {\n                        // the simplified version that we like that takes\n                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                        lerp = this.customEase(lerp);\n                    }\n                }\n\n                // set age percent for all interpolation calculations\n                particle.agePercent = lerp;\n\n                // let each behavior run wild on the active particles\n                for (let i = 0; i < this.updateBehaviors.length; ++i)\n                {\n                    if (this.updateBehaviors[i].updateParticle(particle, delta))\n                    {\n                        this.recycle(particle);\n                        break;\n                    }\n                }\n            }\n        }\n\n        let prevX: number;\n        let prevY: number;\n\n        // if the previous position is valid, store these for later interpolation\n        if (this._prevPosIsValid)\n        {\n            prevX = this._prevEmitterPos.x;\n            prevY = this._prevEmitterPos.y;\n        }\n        // store current position of the emitter as local variables\n        const curX = this.ownerPos.x + this.spawnPos.x;\n        const curY = this.ownerPos.y + this.spawnPos.y;\n        // spawn new particles\n\n        if (this._emit)\n        {\n            // decrease spawn timer\n            this._spawnTimer -= delta < 0 ? 0 : delta;\n            // while _spawnTimer < 0, we have particles to spawn\n            while (this._spawnTimer <= 0)\n            {\n                // determine if the emitter should stop spawning\n                if (this._emitterLife >= 0)\n                {\n                    this._emitterLife -= this._frequency;\n                    if (this._emitterLife <= 0)\n                    {\n                        this._spawnTimer = 0;\n                        this._emitterLife = 0;\n                        this.emit = false;\n                        break;\n                    }\n                }\n                // determine if we have hit the particle limit\n                if (this.particleCount >= this.maxParticles)\n                {\n                    this._spawnTimer += this._frequency;\n                    continue;\n                }\n                let emitPosX: number;\n                let emitPosY: number;\n\n                // If the position has changed and this isn't the first spawn,\n                // interpolate the spawn position\n                if (this._prevPosIsValid && this._posChanged)\n                {\n                    // 1 - _spawnTimer / delta, but _spawnTimer is negative\n                    const lerp = 1 + (this._spawnTimer / delta);\n\n                    emitPosX = ((curX - prevX) * lerp) + prevX;\n                    emitPosY = ((curY - prevY) * lerp) + prevY;\n                }\n                // otherwise just set to the spawn position\n                else\n                {\n                    emitPosX = curX;\n                    emitPosY = curY;\n                }\n\n                let waveFirst: Particle = null;\n                let waveLast: Particle = null;\n\n                // create enough particles to fill the wave\n                for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n                {\n                    // see if we actually spawn one\n                    if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n                    {\n                        continue;\n                    }\n                    // determine the particle lifetime\n                    let lifetime;\n\n                    if (this.minLifetime === this.maxLifetime)\n                    {\n                        lifetime = this.minLifetime;\n                    }\n                    else\n                    {\n                        lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n                    }\n                    // only make the particle if it wouldn't immediately destroy itself\n                    if (-this._spawnTimer >= lifetime)\n                    {\n                        continue;\n                    }\n                    // create particle\n                    let p: Particle;\n\n                    if (this._poolFirst)\n                    {\n                        p = this._poolFirst;\n                        this._poolFirst = this._poolFirst.next;\n                        p.next = null;\n                    }\n                    else\n                    {\n                        p = new Particle(this);\n                    }\n\n                    // initialize particle\n                    p.init(lifetime);\n                    // add the particle to the display list\n                    if (this.addAtBack)\n                    {\n                        this._parent.addChildAt(p, 0);\n                    }\n                    else\n                    {\n                        this._parent.addChild(p);\n                    }\n                    // add particles to list of ones in this wave\n                    if (waveFirst)\n                    {\n                        waveLast.next = p;\n                        p.prev = waveLast;\n                        waveLast = p;\n                    }\n                    else\n                    {\n                        waveLast = waveFirst = p;\n                    }\n                    // increase our particle count\n                    ++this.particleCount;\n                }\n\n                if (waveFirst)\n                {\n                    // add particle to list of active particles\n                    if (this._activeParticlesLast)\n                    {\n                        this._activeParticlesLast.next = waveFirst;\n                        waveFirst.prev = this._activeParticlesLast;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    else\n                    {\n                        this._activeParticlesFirst = waveFirst;\n                        this._activeParticlesLast = waveLast;\n                    }\n                    // run behavior init on particles\n                    for (let i = 0; i < this.initBehaviors.length; ++i)\n                    {\n                        const behavior = this.initBehaviors[i];\n\n                        // if we hit our special key, interrupt behaviors to apply\n                        // emitter position/rotation\n                        if (behavior === PositionParticle)\n                        {\n                            for (let particle = waveFirst, next; particle; particle = next)\n                            {\n                                // save next particle in case we recycle this one\n                                next = particle.next;\n                                // rotate the particle's position by the emitter's rotation\n                                if (this.rotation !== 0)\n                                {\n                                    rotatePoint(this.rotation, particle.position);\n                                    particle.rotation += this.rotation;\n                                }\n                                // offset by the emitter's position\n                                particle.position.x += emitPosX;\n                                particle.position.y += emitPosY;\n\n                                // also, just update the particle's age properties while we are looping through\n                                particle.age += delta;\n                                // determine our interpolation value\n                                let lerp = particle.age * particle.oneOverLife;// lifetime / maxLife;\n\n                                // global ease affects all interpolation calculations\n                                if (this.customEase)\n                                {\n                                    if (this.customEase.length === 4)\n                                    {\n                                        // the t, b, c, d parameters that some tween libraries use\n                                        // (time, initial value, end value, duration)\n                                        lerp = (this.customEase as any)(lerp, 0, 1, 1);\n                                    }\n                                    else\n                                    {\n                                        // the simplified version that we like that takes\n                                        // one parameter, time from 0-1. TweenJS eases provide this usage.\n                                        lerp = this.customEase(lerp);\n                                    }\n                                }\n                                // set age percent for all interpolation calculations\n                                particle.agePercent = lerp;\n                            }\n                        }\n                        else\n                        {\n                            behavior.initParticles(waveFirst);\n                        }\n                    }\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // now update the particles by the time passed, so the particles are spread out properly\n                        for (let i = 0; i < this.updateBehaviors.length; ++i)\n                        {\n                            // we want a positive delta, because a negative delta messes things up\n                            if (this.updateBehaviors[i].updateParticle(particle, -this._spawnTimer))\n                            {\n                                // bail if the particle got reycled\n                                this.recycle(particle);\n                                break;\n                            }\n                        }\n                    }\n                }\n                // increase timer and continue on to any other particles that need to be created\n                this._spawnTimer += this._frequency;\n            }\n        }\n        // if the position changed before this update, then keep track of that\n        if (this._posChanged)\n        {\n            this._prevEmitterPos.x = curX;\n            this._prevEmitterPos.y = curY;\n            this._prevPosIsValid = true;\n            this._posChanged = false;\n        }\n\n        // if we are all done and should destroy ourselves, take care of that\n        if (!this._emit && !this._activeParticlesFirst)\n        {\n            if (this._completeCallback)\n            {\n                const cb = this._completeCallback;\n\n                this._completeCallback = null;\n                cb();\n            }\n            if (this._destroyWhenComplete)\n            {\n                this.destroy();\n            }\n        }\n    }\n\n    /**\n     * Emits a single wave of particles, using standard spawnChance & particlesPerWave settings. Does not affect\n     * regular spawning through the frequency, and ignores the emit property. The max particle count is respected, however,\n     * so if there are already too many particles then nothing will happen.\n     */\n    public emitNow(): void\n    {\n        const emitPosX = this.ownerPos.x + this.spawnPos.x;\n        const emitPosY = this.ownerPos.y + this.spawnPos.y;\n\n        let waveFirst: Particle = null;\n        let waveLast: Particle = null;\n\n        // create enough particles to fill the wave\n        for (let len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), i = 0; i < len; ++i)\n        {\n            // see if we actually spawn one\n            if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\n            {\n                continue;\n            }\n            // create particle\n            let p: Particle;\n\n            if (this._poolFirst)\n            {\n                p = this._poolFirst;\n                this._poolFirst = this._poolFirst.next;\n                p.next = null;\n            }\n            else\n            {\n                p = new Particle(this);\n            }\n\n            let lifetime: number;\n\n            if (this.minLifetime === this.maxLifetime)\n            {\n                lifetime = this.minLifetime;\n            }\n            else\n            {\n                lifetime = (Math.random() * (this.maxLifetime - this.minLifetime)) + this.minLifetime;\n            }\n            // initialize particle\n            p.init(lifetime);\n            // add the particle to the display list\n            if (this.addAtBack)\n            {\n                this._parent.addChildAt(p, 0);\n            }\n            else\n            {\n                this._parent.addChild(p);\n            }\n            // add particles to list of ones in this wave\n            if (waveFirst)\n            {\n                waveLast.next = p;\n                p.prev = waveLast;\n                waveLast = p;\n            }\n            else\n            {\n                waveLast = waveFirst = p;\n            }\n            // increase our particle count\n            ++this.particleCount;\n        }\n\n        if (waveFirst)\n        {\n            // add particle to list of active particles\n            if (this._activeParticlesLast)\n            {\n                this._activeParticlesLast.next = waveFirst;\n                waveFirst.prev = this._activeParticlesLast;\n                this._activeParticlesLast = waveLast;\n            }\n            else\n            {\n                this._activeParticlesFirst = waveFirst;\n                this._activeParticlesLast = waveLast;\n            }\n            // run behavior init on particles\n            for (let i = 0; i < this.initBehaviors.length; ++i)\n            {\n                const behavior = this.initBehaviors[i];\n\n                // if we hit our special key, interrupt behaviors to apply\n                // emitter position/rotation\n                if (behavior === PositionParticle)\n                {\n                    for (let particle = waveFirst, next; particle; particle = next)\n                    {\n                        // save next particle in case we recycle this one\n                        next = particle.next;\n                        // rotate the particle's position by the emitter's rotation\n                        if (this.rotation !== 0)\n                        {\n                            rotatePoint(this.rotation, particle.position);\n                            particle.rotation += this.rotation;\n                        }\n                        // offset by the emitter's position\n                        particle.position.x += emitPosX;\n                        particle.position.y += emitPosY;\n                    }\n                }\n                else\n                {\n                    behavior.initParticles(waveFirst);\n                }\n            }\n        }\n    }\n\n    /**\n     * Kills all active particles immediately.\n     */\n    public cleanup(): void\n    {\n        let particle;\n        let next;\n\n        for (particle = this._activeParticlesFirst; particle; particle = next)\n        {\n            next = particle.next;\n            this.recycle(particle, true);\n        }\n        this._activeParticlesFirst = this._activeParticlesLast = null;\n        this.particleCount = 0;\n    }\n\n    /**\n     * If this emitter has been destroyed. Note that a destroyed emitter can still be reused, after\n     * having a new parent set and being reinitialized.\n     */\n    public get destroyed(): boolean\n    {\n        return !(this._parent && this.initBehaviors.length);\n    }\n\n    /**\n     * Destroys the emitter and all of its particles.\n     */\n    public destroy(): void\n    {\n        // make sure we aren't still listening to any tickers\n        this.autoUpdate = false;\n        // puts all active particles in the pool, and removes them from the particle parent\n        this.cleanup();\n        // wipe the pool clean\n        let next;\n\n        for (let particle = this._poolFirst; particle; particle = next)\n        {\n            // store next value so we don't lose it in our destroy call\n            next = particle.next;\n            particle.destroy();\n        }\n        this._poolFirst = this._parent = this.spawnPos = this.ownerPos\n            = this.customEase = this._completeCallback = null;\n\n        this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0;\n    }\n}\n","import { Particle } from '../../Particle';\nimport type { ObjectProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * A SpawnShape that randomly picks locations inside a rectangle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'rect',\n *     data: {\n *          x: 0,\n *          y: 0,\n *          w: 10,\n *          h: 100\n *     }\n * }\n * ```\n */\nexport class Rectangle implements SpawnShape\n{\n    public static type = 'rect';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X (left) position of the rectangle.\n     */\n    public x: number;\n    /**\n     * Y (top) position of the rectangle.\n     */\n    public y: number;\n    /**\n     * Width of the rectangle.\n     */\n    public w: number;\n    /**\n     * Height of the rectangle.\n     */\n    public h: number;\n\n    constructor(config: {\n        /**\n         * X (left) position of the rectangle.\n         */\n        x: number;\n        /**\n         * Y (top) position of the rectangle.\n         */\n        y: number;\n        /**\n         * Width of the rectangle.\n         */\n        w: number;\n        /**\n         * Height of the rectangle.\n         */\n        h: number;\n    })\n    {\n        this.x = config.x;\n        this.y = config.y;\n        this.w = config.w;\n        this.h = config.h;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random point in the rectangle\n        particle.x = (Math.random() * this.w) + this.x;\n        particle.y = (Math.random() * this.h) + this.y;\n    }\n}\n","import { Particle } from '../../Particle';\nimport { rotatePoint } from '../../ParticleUtils';\nimport { ObjectProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\n/**\n * A class for spawning particles in a circle or ring.\n * Can optionally apply rotation to particles so that they are aimed away from the center of the circle.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'torus',\n *     data: {\n *          radius: 30,\n *          x: 0,\n *          y: 0,\n *          innerRadius: 10,\n *          rotation: true\n *     }\n * }\n * ```\n */\nexport class Torus implements SpawnShape\n{\n    public static type = 'torus';\n    public static editorConfig: ObjectProperty = null;\n    /**\n     * X position of the center of the shape.\n     */\n    public x: number;\n    /**\n     * Y position of the center of the shape.\n     */\n    public y: number;\n    /**\n     * Radius of circle, or outer radius of a ring.\n     */\n    public radius: number;\n    /**\n     * Inner radius of a ring. Use 0 to have a circle.\n     */\n    public innerRadius: number;\n    /**\n     * If rotation should be applied to particles.\n     */\n    public rotation: boolean;\n\n    constructor(config: {\n        /**\n         * Radius of circle, or outer radius of a ring. Note that this uses the full name of 'radius',\n         * where earlier versions of the library may have used 'r'.\n         */\n        radius: number;\n        /**\n         * X position of the center of the shape.\n         */\n        x: number;\n        /**\n         * Y position of the center of the shape.\n         */\n        y: number;\n        /**\n         * Inner radius of a ring. Omit, or use 0, to have a circle.\n         */\n        innerRadius?: number;\n        /**\n         * If rotation should be applied to particles, pointing them away from the center of the torus.\n         * Defaults to false.\n         */\n        affectRotation?: boolean\n    })\n    {\n        this.x = config.x || 0;\n        this.y = config.y || 0;\n        this.radius = config.radius;\n        this.innerRadius = config.innerRadius || 0;\n        this.rotation = !!config.affectRotation;\n    }\n\n    getRandPos(particle: Particle): void\n    {\n        // place the particle at a random radius in the ring\n        if (this.innerRadius !== this.radius)\n        {\n            particle.x = (Math.random() * (this.radius - this.innerRadius)) + this.innerRadius;\n        }\n        else\n        {\n            particle.x = this.radius;\n        }\n        particle.y = 0;\n        // rotate the point to a random angle in the circle\n        const angle = Math.random() * Math.PI * 2;\n\n        if (this.rotation)\n        {\n            particle.rotation += angle;\n        }\n        rotatePoint(angle, particle.position);\n        // now add in the center of the torus\n        particle.position.x += this.x;\n        particle.position.y += this.y;\n    }\n}\n","import { IPointData } from '@pixi/math';\nimport { ListProperty } from '../editor/Types';\nimport { SpawnShape } from './SpawnShape';\n\ninterface Segment\n{\n    p1: IPointData;\n    p2: IPointData;\n    l: number;\n}\n\n/**\n * A spawn shape that picks a random position along a series of line segments. If those\n * line segments form a polygon, particles will only be placed on the perimeter of that polygon.\n *\n * Example config:\n * ```javascript\n * {\n *      type: 'polygonalChain',\n *      data: [\n *          [{x: 0, y: 0}, {x: 10, y: 10}, {x: 20, y: 0}],\n *          [{x: 0, y, -10}, {x: 10, y: 0}, {x: 20, y: -10}]\n *      ]\n * }\n * ```\n */\nexport class PolygonalChain implements SpawnShape\n{\n    public static type = 'polygonalChain';\n    public static editorConfig: ListProperty = null;\n    /**\n     * List of segment objects in the chain.\n     */\n    private segments: Segment[];\n    /**\n     * Total length of all segments of the chain.\n     */\n    private totalLength: number;\n    /**\n     * Total length of segments up to and including the segment of the same index.\n     * Used for weighted random selection of segment.\n     */\n    private countingLengths: number[];\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    constructor(data: IPointData[]|IPointData[][])\n    {\n        this.segments = [];\n        this.countingLengths = [];\n        this.totalLength = 0;\n        this.init(data);\n    }\n\n    /**\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\n     */\n    private init(data: IPointData[]|IPointData[][]): void\n    {\n        // if data is not present, set up a segment of length 0\n        if (!data || !data.length)\n        {\n            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });\n        }\n        else if (Array.isArray(data[0]))\n        {\n            // list of segment chains, each defined as a list of points\n            for (let i = 0; i < data.length; ++i)\n            {\n                // loop through the chain, connecting points\n                const chain = data[i] as IPointData[];\n                let prevPoint = chain[0] as IPointData;\n\n                for (let j = 1; j < chain.length; ++j)\n                {\n                    const second = chain[j] as IPointData;\n\n                    this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                    prevPoint = second;\n                }\n            }\n        }\n        else\n        {\n            let prevPoint = data[0] as IPointData;\n            // list of points\n\n            for (let i = 1; i < data.length; ++i)\n            {\n                const second = data[i] as IPointData;\n\n                this.segments.push({ p1: prevPoint, p2: second, l: 0 });\n                prevPoint = second;\n            }\n        }\n        // now go through our segments to calculate the lengths so that we\n        // can set up a nice weighted random distribution\n        for (let i = 0; i < this.segments.length; ++i)\n        {\n            const { p1, p2 } = this.segments[i];\n            const segLength = Math.sqrt(((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y)));\n            // save length so we can turn a random number into a 0-1 interpolation value later\n\n            this.segments[i].l = segLength;\n            this.totalLength += segLength;\n            // keep track of the length so far, counting up\n            this.countingLengths.push(this.totalLength);\n        }\n    }\n\n    /**\n     * Gets a random point in the chain.\n     * @param out The point to store the selected position in.\n     */\n    public getRandPos(out: IPointData): void\n    {\n        // select a random spot in the length of the chain\n        const rand = Math.random() * this.totalLength;\n        let chosenSeg: Segment;\n        let lerp: number;\n\n        // if only one segment, it wins\n        if (this.segments.length === 1)\n        {\n            chosenSeg = this.segments[0];\n            lerp = rand;\n        }\n        else\n        {\n            // otherwise, go through countingLengths until we have determined\n            // which segment we chose\n            for (let i = 0; i < this.countingLengths.length; ++i)\n            {\n                if (rand < this.countingLengths[i])\n                {\n                    chosenSeg = this.segments[i];\n                    // set lerp equal to the length into that segment\n                    // (i.e. the remainder after subtracting all the segments before it)\n                    lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\n                    break;\n                }\n            }\n        }\n        // divide lerp by the segment length, to result in a 0-1 number.\n        lerp /= chosenSeg.l || 1;\n        const { p1, p2 } = chosenSeg;\n        // now calculate the position in the segment that the lerp value represents\n\n        out.x = p1.x + (lerp * (p2.x - p1.x));\n        out.y = p1.y + (lerp * (p2.y - p1.y));\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, scaleBy, length } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Movement behavior that handles movement by applying a constant acceleration to all particles.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"moveAcceleration\",\n *     \"config\": {\n *          \"accel\": {\n *               \"x\": 0,\n *               \"y\": 2000\n *          },\n *          \"minStart\": 600,\n *          \"maxStart\": 600,\n *          \"rotate\": true\n *     }\n *}\n * ```\n */\nexport class AccelerationBehavior implements IEmitterBehavior\n{\n    public static type = 'moveAcceleration';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // doesn't _really_ need to be late, but doing so ensures that we can override any\n    // rotation behavior that is mistakenly added\n    public order = BehaviorOrder.Late;\n    private minStart: number;\n    private maxStart: number;\n    private accel: {x: number; y: number};\n    private rotate: boolean;\n    private maxSpeed: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle, in world units/second.\n         */\n        minStart: number;\n        /**\n         * Maximum speed when initializing the particle. in world units/second.\n         */\n        maxStart: number;\n        /**\n         * Constant acceleration, in the coordinate space of the particle parent, in world units/second.\n         */\n        accel: {x: number; y: number};\n        /**\n         * Rotate the particle with its direction of movement.\n         * While initial movement direction reacts to rotation settings, this overrides any dynamic rotation.\n         * Defaults to false.\n         */\n        rotate?: boolean;\n        /**\n         * Maximum linear speed. 0 is unlimited. Defaults to 0.\n         */\n        maxSpeed?: number;\n    })\n    {\n        this.minStart = config.minStart;\n        this.maxStart = config.maxStart;\n        this.accel = config.accel;\n        this.rotate = !!config.rotate;\n        this.maxSpeed = config.maxSpeed ?? 0;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const vel = particle.config.velocity;\n        const oldVX = vel.x;\n        const oldVY = vel.y;\n\n        vel.x += this.accel.x * deltaSec;\n        vel.y += this.accel.y * deltaSec;\n        if (this.maxSpeed)\n        {\n            const currentSpeed = length(vel);\n            // if we are going faster than we should, clamp at the max speed\n            // DO NOT recalculate vector length\n\n            if (currentSpeed > this.maxSpeed)\n            {\n                scaleBy(vel, this.maxSpeed / currentSpeed);\n            }\n        }\n        // calculate position delta by the midpoint between our old velocity and our new velocity\n        particle.x += (oldVX + vel.x) / 2 * deltaSec;\n        particle.y += (oldVY + vel.y) / 2 * deltaSec;\n        if (this.rotate)\n        {\n            particle.rotation = Math.atan2(vel.y, vel.x);\n        }\n    }\n}\n","import { combineRGBComponents, SimpleEase, Color } from './ParticleUtils';\nimport { PropertyNode } from './PropertyNode';\n\nfunction intValueSimple(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    return ((this.first.next.value - this.first.value) * lerp) + this.first.value;\n}\n\nfunction intColorSimple(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    const curVal = this.first.value;\n    const nextVal = this.first.next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueComplex(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n\n    return ((next.value - current.value) * lerp) + current.value;\n}\n\nfunction intColorComplex(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n    let next = current.next;\n\n    while (lerp > next.time)\n    {\n        current = next;\n        next = next.next;\n    }\n    // convert the lerp value to the segment range\n    lerp = (lerp - current.time) / (next.time - current.time);\n    const curVal = current.value;\n    const nextVal = next.value;\n    const r = ((nextVal.r - curVal.r) * lerp) + curVal.r;\n    const g = ((nextVal.g - curVal.g) * lerp) + curVal.g;\n    const b = ((nextVal.b - curVal.b) * lerp) + curVal.b;\n\n    return combineRGBComponents(r, g, b);\n}\n\nfunction intValueStepped(this: PropertyList<number>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n\n    return current.value;\n}\n\nfunction intColorStepped(this: PropertyList<Color>, lerp: number): number\n{\n    if (this.ease) lerp = this.ease(lerp);\n\n    // make sure we are on the right segment\n    let current = this.first;\n\n    while (current.next && lerp > current.next.time)\n    {\n        current = current.next;\n    }\n    const curVal = current.value;\n\n    return combineRGBComponents(curVal.r, curVal.g, curVal.b);\n}\n\n/**\n * Singly linked list container for keeping track of interpolated properties for particles.\n * Each Particle will have one of these for each interpolated property.\n */\nexport class PropertyList<V>\n{\n    /**\n     * The first property node in the linked list.\n     */\n    public first: PropertyNode<V>;\n    /**\n     * Calculates the correct value for the current interpolation value. This method is set in\n     * the reset() method.\n     * @param lerp The interpolation value from 0-1.\n     * @return The interpolated value. Colors are converted to the hex value.\n     */\n    public interpolate: (lerp: number) => number;\n    /**\n     * A custom easing method for this list.\n     * @param lerp The interpolation value from 0-1.\n     * @return The eased value, also from 0-1.\n     */\n    public ease: SimpleEase;\n    /**\n     * If this list manages colors, which requires a different method for interpolation.\n     */\n    private isColor: boolean;\n\n    /**\n     * @param isColor If this list handles color values\n     */\n    constructor(isColor = false)\n    {\n        this.first = null;\n        this.isColor = !!isColor;\n        this.interpolate = null;\n        this.ease = null;\n    }\n\n    /**\n     * Resets the list for use.\n     * @param first The first node in the list.\n     * @param first.isStepped If the values should be stepped instead of interpolated linearly.\n     */\n    public reset(first: PropertyNode<V>): void\n    {\n        this.first = first;\n        const isSimple = first.next && first.next.time >= 1;\n\n        if (isSimple)\n        {\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\n        }\n        else if (first.isStepped)\n        {\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\n        }\n        else\n        {\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\n        }\n        this.ease = this.first.ease;\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * An Alpha behavior that applies an interpolated or stepped list of values to the particle's opacity.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alpha',\n *     config: {\n *         alpha: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nexport class AlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alpha';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: ValueList<number>;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.alpha));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.list.first.value;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.alpha = this.list.interpolate(particle.agePercent);\n    }\n}\n\n/**\n * An Alpha behavior that applies a static value to the particle's opacity at particle initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'alphaStatic',\n *     config: {\n *         alpha: 0.75,\n *     }\n * }\n * ```\n */\nexport class StaticAlphaBehavior implements IEmitterBehavior\n{\n    public static type = 'alphaStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Transparency of the particles from 0 (transparent) to 1 (opaque)\n         */\n        alpha: number;\n    })\n    {\n        this.value = config.alpha;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.alpha = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * The format of a single animation to be used on a particle.\n */\nexport interface AnimatedParticleArt\n{\n    /**\n     * Framerate for the animation (in frames per second). A value of -1 will tie the framerate to\n     * the particle's lifetime so that the animation lasts exactly as long as the particle.\n     */\n    framerate: -1|number;\n    /**\n     * If the animation should loop. Defaults to false.\n     */\n    loop?: boolean;\n    /**\n     * A list of textures or frame descriptions for duplicated frames.\n     * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n     * Example of a texture repeated for 5 frames, followed by a second texture for one frame:\n     * ```javascript\n     * [{texture: 'myFirstTex', count: 5}, 'mySecondTex']\n     * ```\n     */\n    textures: (string|Texture|{texture: string|Texture; count: number})[];\n}\n\ninterface ParsedAnimatedParticleArt\n{\n    textures: Texture[];\n    duration: number;\n    framerate: number;\n    loop: boolean;\n}\n\nfunction getTextures(textures: (string|Texture|{texture: string|Texture; count: number})[]): Texture[]\n{\n    const outTextures: Texture[] = [];\n\n    for (let j = 0; j < textures.length; ++j)\n    {\n        let tex = textures[j];\n\n        if (typeof tex === 'string')\n        {\n            outTextures.push(GetTextureFromString(tex));\n        }\n        else if (tex instanceof Texture)\n        {\n            outTextures.push(tex);\n        }\n        // assume an object with extra data determining duplicate frame data\n        else\n        {\n            let dupe = tex.count || 1;\n\n            if (typeof tex.texture === 'string')\n            {\n                tex = GetTextureFromString(tex.texture);\n            }\n            else// if(tex.texture instanceof Texture)\n            {\n                tex = tex.texture;\n            }\n            for (; dupe > 0; --dupe)\n            {\n                outTextures.push(tex);\n            }\n        }\n    }\n\n    return outTextures;\n}\n\n/**\n * A Texture behavior that picks a random animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedRandom',\n *     config: {\n *         anims: [\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame1', 'frame2', 'frame3']\n *              },\n *              {\n *                  framerate: 25,\n *                  loop: true,\n *                  textures: ['frame3', 'frame2', 'frame1']\n *              }\n *         ],\n *     }\n * }\n * ```\n */\nexport class RandomAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anims: ParsedAnimatedParticleArt[];\n    constructor(config: {\n        /**\n         * Animation configuration to use for each particle, randomly chosen from the list.\n         */\n        anims: AnimatedParticleArt[];\n    })\n    {\n        this.anims = [];\n        for (let i = 0; i < config.anims.length; ++i)\n        {\n            const anim = config.anims[i];\n            const textures = getTextures(anim.textures);\n            // eslint-disable-next-line no-nested-ternary\n            const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n            const parsedAnim: ParsedAnimatedParticleArt = {\n                textures,\n                duration: framerate > 0 ? textures.length / framerate : 0,\n                framerate,\n                loop: framerate > 0 ? !!anim.loop : false,\n            };\n\n            this.anims.push(parsedAnim);\n        }\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.anims.length);\n            const anim = next.config.anim = this.anims[index];\n\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const config = particle.config;\n        const anim = config.anim;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (config.anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n\n/**\n * A Texture behavior that uses a single animation for each particle to play.\n * See {@link AnimatedParticleArt} for detailed configuration info.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'animatedSingle',\n *     config: {\n *         anim: {\n *              framerate: 25,\n *              loop: true,\n *              textures: ['frame1', 'frame2', 'frame3']\n *         }\n *     }\n * }\n * ```\n */\nexport class SingleAnimatedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'animatedSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private anim: ParsedAnimatedParticleArt;\n    constructor(config: {\n        /**\n         * Animation configuration to use for each particle.\n         */\n        anim: AnimatedParticleArt;\n    })\n    {\n        const anim = config.anim;\n        const textures = getTextures(anim.textures);\n        // eslint-disable-next-line no-nested-ternary\n        const framerate = anim.framerate < 0 ? -1 : (anim.framerate > 0 ? anim.framerate : 60);\n\n        this.anim = {\n            textures,\n            duration: framerate > 0 ? textures.length / framerate : 0,\n            framerate,\n            loop: framerate > 0 ? !!anim.loop : false,\n        };\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const anim = this.anim;\n\n        while (next)\n        {\n            next.texture = anim.textures[0];\n            next.config.animElapsed = 0;\n            // if anim should match particle life exactly\n            if (anim.framerate === -1)\n            {\n                next.config.animDuration = next.maxLife;\n                next.config.animFramerate = anim.textures.length / next.maxLife;\n            }\n            else\n            {\n                next.config.animDuration = anim.duration;\n                next.config.animFramerate = anim.framerate;\n            }\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const anim = this.anim;\n        const config = particle.config;\n\n        config.animElapsed += deltaSec;\n        if (config.animElapsed >= config.animDuration)\n        {\n            // loop elapsed back around\n            if (anim.loop)\n            {\n                config.animElapsed = config.animElapsed % config.animDuration;\n            }\n            // subtract a small amount to prevent attempting to go past the end of the animation\n            else\n            {\n                config.animElapsed = config.animDuration - 0.000001;\n            }\n        }\n        // add a very small number to the frame and then floor it to avoid\n        // the frame being one short due to floating point errors.\n        const frame = ((config.animElapsed * config.animFramerate) + 0.0000001) | 0;\n\n        // in the very rare case that framerate * elapsed math ends up going past the end, use the last texture\n        particle.texture = anim.textures[frame] || anim.textures[anim.textures.length - 1] || Texture.EMPTY;\n    }\n}\n","import { Particle } from '../Particle';\nimport { getBlendMode } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Blend Mode behavior that applies a blend mode value to the particle at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'blendMode',\n *     config: {\n *         blendMode: 'multiply',\n *     }\n * }\n * ```\n */\nexport class BlendModeBehavior implements IEmitterBehavior\n{\n    public static type = 'blendMode';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: string;\n    constructor(config: {\n        /**\n         * Blend mode of all particles. This value is a key from\n         * [PixiJs's BLEND_MODE enum](https://pixijs.download/release/docs/PIXI.html#BLEND_MODES).\n         */\n        blendMode: string;\n    })\n    {\n        this.value = config.blendMode;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.blendMode = getBlendMode(this.value);\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { DEG_TO_RADS, rotatePoint } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that sends particles out from a single point or ring, and is capable of evenly spacing\n * the particle's starting angles.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnBurst',\n *     config: {\n *          spacing: 90,\n *          start: 0,\n *          distance: 40,\n *     }\n * }\n * ```\n */\nexport class BurstSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnBurst';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n    private spacing: number;\n    private start: number;\n    private distance: number;\n\n    constructor(config: {\n        /**\n         * Description: Spacing between each particle spawned in a wave, in degrees.\n         */\n        spacing: number;\n        /**\n         * Description: Angle to start placing particles at, in degrees. 0 is facing right, 90 is facing upwards.\n         */\n        start: number;\n        /**\n         * Description: Distance from the emitter to spawn particles, forming a ring/arc.\n         */\n        distance: number;\n    })\n    {\n        this.spacing = config.spacing * DEG_TO_RADS;\n        this.start = config.start * DEG_TO_RADS;\n        this.distance = config.distance;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let count = 0;\n        let next = first;\n\n        while (next)\n        {\n            let angle: number;\n\n            if (this.spacing)\n            {\n                angle = this.start + (this.spacing * count);\n            }\n            else\n            {\n                angle = Math.random() * Math.PI * 2;\n            }\n\n            next.rotation = angle;\n            if (this.distance)\n            {\n                next.position.x = this.distance;\n                rotatePoint(angle, next.position);\n            }\n            next = next.next;\n            ++count;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { Color, combineRGBComponents } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Color behavior that applies an interpolated or stepped list of values to the particle's tint property.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'color',\n *     config: {\n *         color: {\n *              list: [{value: '#ff0000' time: 0}, {value: '#00ff00', time: 0.5}, {value: '#0000ff', time: 1}]\n *         },\n *     }\n * }\n * ```\n */\nexport class ColorBehavior implements IEmitterBehavior\n{\n    public static type = 'color';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<Color>;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: ValueList<string>;\n    })\n    {\n        this.list = new PropertyList(true);\n        this.list.reset(PropertyNode.createList(config.color));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n        const color = this.list.first.value;\n        const tint = combineRGBComponents(color.r, color.g, color.b);\n\n        while (next)\n        {\n            next.tint = tint;\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.tint = this.list.interpolate(particle.agePercent);\n    }\n}\n\n/**\n * A Color behavior that applies a single color to the particle's tint property at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'colorStatic',\n *     config: {\n *         color: '#ffff00',\n *     }\n * }\n * ```\n */\nexport class StaticColorBehavior implements IEmitterBehavior\n{\n    public static type = 'colorStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private value: number;\n    constructor(config: {\n        /**\n         * Color of the particles as 6 digit hex codes.\n         */\n        color: string;\n    })\n    {\n        let color = config.color;\n\n        if (color.charAt(0) === '#')\n        {\n            color = color.substr(1);\n        }\n        else if (color.indexOf('0x') === 0)\n        {\n            color = color.substr(2);\n        }\n\n        this.value = parseInt(color, 16);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.tint = this.value;\n            next = next.next;\n        }\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Texture behavior that assigns a texture to each particle from its list, in order, before looping around to the first\n * texture again. String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureOrdered',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nexport class OrderedTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureOrdered';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    private index: number;\n    constructor(config: {\n        /**\n         * Images to use for each particle, used in order before looping around\n         */\n        textures: Texture[];\n    })\n    {\n        this.index = 0;\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.textures[this.index];\n            if (++this.index >= this.textures.length)\n            {\n                this.index = 0;\n            }\n            next = next.next;\n        }\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, verbose } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A helper point for math things.\n * @hidden\n */\nconst helperPoint = new Point();\n\n/**\n * A hand picked list of Math functions (and a couple properties) that are\n * allowable. They should be used without the preceding \"Math.\"\n * @hidden\n */\nconst MATH_FUNCS = [\n    'E',\n    'LN2',\n    'LN10',\n    'LOG2E',\n    'LOG10E',\n    'PI',\n    'SQRT1_2',\n    'SQRT2',\n    'abs',\n    'acos',\n    'acosh',\n    'asin',\n    'asinh',\n    'atan',\n    'atanh',\n    'atan2',\n    'cbrt',\n    'ceil',\n    'cos',\n    'cosh',\n    'exp',\n    'expm1',\n    'floor',\n    'fround',\n    'hypot',\n    'log',\n    'log1p',\n    'log10',\n    'log2',\n    'max',\n    'min',\n    'pow',\n    'random',\n    'round',\n    'sign',\n    'sin',\n    'sinh',\n    'sqrt',\n    'tan',\n    'tanh',\n];\n/**\n * create an actual regular expression object from the string\n * @hidden\n */\nconst WHITELISTER = new RegExp(\n    [\n        // Allow the 4 basic operations, parentheses and all numbers/decimals, as well\n        // as 'x', for the variable usage.\n        '[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]',\n    ].concat(MATH_FUNCS).join('|'),\n    'g',\n);\n\n/**\n * Parses a string into a function for path following.\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\n * names, and using `new Function()` to generate a function.\n * @hidden\n * @param pathString The string to parse.\n * @return The path function - takes x, outputs y.\n */\nfunction parsePath(pathString: string): (x: number) => number\n{\n    const matches = pathString.match(WHITELISTER);\n\n    for (let i = matches.length - 1; i >= 0; --i)\n    {\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0)\n        { matches[i] = `Math.${matches[i]}`; }\n    }\n    pathString = matches.join('');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('x', `return ${pathString};`) as (x: number) => number;\n}\n\n/**\n * A particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\n * \"5x + 3\".\n * To use this class, the behavior config must have a \"path\" string or function.\n *\n * A string should have \"x\" in it to represent movement (from the\n * speed settings of the behavior). It may have numbers, parentheses, the four basic\n * operations, and any Math functions or properties (without the preceding \"Math.\").\n * The overall movement of the particle and the expression value become x and y positions for\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\n * the particle.\n *\n * A function merely needs to accept the \"x\" argument and output the a corresponding \"y\" value.\n *\n * Some example paths:\n *\n * * `\"sin(x/10) * 20\"` A sine wave path.\n * * `\"cos(x/100) * 30\"` Particles curve counterclockwise (for medium speed/low lifetime particles)\n * * `\"pow(x/10, 2) / 2\"` Particles curve clockwise (remember, +y is down).\n * * `(x) => Math.floor(x) * 3` Supplying an existing function should look like this\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"movePath\",\n *     \"config\": {\n *          \"path\": \"round(sin(x) * 2\",\n *          \"speed\": {\n *              \"list\": [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          \"minMult\": 0.8\n *     }\n *}\n */\nexport class PathBehavior implements IEmitterBehavior\n{\n    public static type = 'movePath';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    // *MUST* happen after other behaviors do initialization so that we can read initial transformations\n    public order = BehaviorOrder.Late;\n    /**\n     * The function representing the path the particle should take.\n     */\n    private path: (x: number) => number;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Algebraic expression describing the movement of the particle.\n         */\n        path: string|((x: number) => number);\n        /**\n         * Speed of the particles in world units/second. This affects the x value in the path.\n         * Unlike normal speed movement, this can have negative values.\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly generated and multiplied\n         * with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        if (config.path)\n        {\n            if (typeof config.path === 'function')\n            {\n                this.path = config.path;\n            }\n            else\n            {\n                try\n                {\n                    this.path = parsePath(config.path);\n                }\n                catch (e)\n                {\n                    if (verbose)\n                    {\n                        console.error('PathParticle: error in parsing path expression', e);\n                    }\n                    this.path = null;\n                }\n            }\n        }\n        else\n        {\n            if (verbose)\n            {\n                console.error('PathParticle requires a path value in its config!');\n            }\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n            this.path = (x) => x;\n        }\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            /*\n             * The initial rotation in degrees of the particle, because the direction of the path\n             * is based on that.\n             */\n            next.config.initRotation = next.rotation;\n            /* The initial position of the particle, as all path movement is added to that. */\n            if (!next.config.initPosition)\n            {\n                next.config.initPosition = new Point(next.x, next.y);\n            }\n            else\n            {\n                (next.config.initPosition as Point).copyFrom(next.position);\n            }\n            /* Total single directional movement, due to speed. */\n            next.config.movement = 0;\n\n            // also do speed multiplier, since this includes basic speed movement\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        // increase linear movement based on speed\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n\n        particle.config.movement += speed * deltaSec;\n        // set up the helper point for rotation\n        helperPoint.x = particle.config.movement;\n        helperPoint.y = this.path(helperPoint.x);\n        rotatePoint(particle.config.initRotation, helperPoint);\n        particle.position.x = particle.config.initPosition.x + helperPoint.x;\n        particle.position.y = particle.config.initPosition.y + helperPoint.y;\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that sends particles out from a single point at the emitter's position.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnPoint',\n *     config: {}\n * }\n * ```\n */\nexport class PointSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnPoint';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    order = BehaviorOrder.Spawn;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    initParticles(_first: Particle): void\n    {\n        // really just a no-op\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Texture behavior that assigns a random texture to each particle from its list.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureRandom',\n *     config: {\n *         textures: [\"myTex1Id\", \"myTex2Id\", \"myTex3Id\", \"myTex4Id\"],\n *     }\n * }\n * ```\n */\nexport class RandomTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureRandom';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private textures: Texture[];\n    constructor(config: {\n        /**\n         * Images to use for each particle, randomly chosen from the list.\n         */\n        textures: (Texture|string)[];\n    })\n    {\n        this.textures = config.textures.map((tex) => (typeof tex === 'string' ? GetTextureFromString(tex) : tex));\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const index = Math.floor(Math.random() * this.textures.length);\n\n            next.texture = this.textures[index];\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { DEG_TO_RADS } from '../ParticleUtils';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Rotation behavior that handles starting rotation, rotation speed, and rotational acceleration.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotation\",\n *     \"config\": {\n *          \"minStart\": 0,\n *          \"maxStart\": 180,\n *          \"minSpeed\": 30,\n *          \"maxSpeed\": 45,\n *          \"accel\": 20\n *     }\n *}\n * ```\n */\nexport class RotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private minStart: number;\n    private maxStart: number;\n    private minSpeed: number;\n    private maxSpeed: number;\n    private accel: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        minStart: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        maxStart: number;\n        /**\n         * Minimum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        minSpeed: number;\n        /**\n         * Maximum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.\n         */\n        maxSpeed: number;\n        /**\n         * Constant rotational acceleration of the particles, in degrees/second/second.\n         */\n        accel: number;\n    })\n    {\n        this.minStart = config.minStart * DEG_TO_RADS;\n        this.maxStart = config.maxStart * DEG_TO_RADS;\n        this.minSpeed = config.minSpeed * DEG_TO_RADS;\n        this.maxSpeed = config.maxSpeed * DEG_TO_RADS;\n        this.accel = config.accel * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.minStart === this.maxStart)\n            {\n                next.rotation += this.maxStart;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.maxStart - this.minStart)) + this.minStart;\n            }\n            next.config.rotSpeed = (Math.random() * (this.maxSpeed - this.minSpeed)) + this.minSpeed;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        if (this.accel)\n        {\n            const oldSpeed = particle.config.rotSpeed;\n\n            particle.config.rotSpeed += this.accel * deltaSec;\n            particle.rotation += (particle.config.rotSpeed + oldSpeed) / 2 * deltaSec;\n        }\n        else\n        {\n            particle.rotation += particle.config.rotSpeed * deltaSec;\n        }\n    }\n}\n\n/**\n * A Rotation behavior that handles starting rotation.\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"rotationStatic\",\n *     \"config\": {\n *          \"min\": 0,\n *          \"max\": 180,\n *     }\n *}\n * ```\n */\nexport class StaticRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'rotationStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        min: number;\n        /**\n         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min * DEG_TO_RADS;\n        this.max = config.max * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            if (this.min === this.max)\n            {\n                next.rotation += this.max;\n            }\n            else\n            {\n                next.rotation += (Math.random() * (this.max - this.min)) + this.min;\n            }\n\n            next = next.next;\n        }\n    }\n}\n\n/**\n * A Rotation behavior that blocks all rotation caused by spawn settings,\n * by resetting it to the specified rotation (or 0).\n *\n * Example configuration:\n * ```javascript\n * {\n *     \"type\": \"noRotation\",\n *     \"config\": {\n *          \"rotation\": 0\n *     }\n *}\n * ```\n */\nexport class NoRotationBehavior implements IEmitterBehavior\n{\n    public static type = 'noRotation';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late + 1;\n\n    private rotation: number;\n    constructor(config: {\n        /**\n         * Locked rotation of the particles, in degrees. 0 is facing right, 90 is upwards.\n         */\n        rotation?: number;\n    })\n    {\n        this.rotation = (config.rotation || 0) * DEG_TO_RADS;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.rotation = this.rotation;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Scale behavior that applies an interpolated or stepped list of values to the particle's x & y scale.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scale',\n *     config: {\n *          scale: {\n *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}],\n *              isStepped: true\n *          },\n *          minMult: 0.5\n *     }\n * }\n * ```\n */\nexport class ScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scale';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Scale of the particles, with a minimum value of 0\n         */\n        scale: ValueList<number>;\n        /**\n         * A value between minimum scale multipler and 1 is randomly\n         * generated and multiplied with each scale value to provide the actual scale for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.scale));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.scaleMult = mult;\n            next.scale.x = next.scale.y = this.list.first.value * mult;\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle): void\n    {\n        particle.scale.x = particle.scale.y = this.list.interpolate(particle.agePercent) * particle.config.scaleMult;\n    }\n}\n\n/**\n * A Scale behavior that applies a randomly picked value to the particle's x & y scale at initialization.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'scaleStatic',\n *     config: {\n *         min: 0.25,\n *         max: 0.75,\n *     }\n * }\n * ```\n */\nexport class StaticScaleBehavior implements IEmitterBehavior\n{\n    public static type = 'scaleStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum scale of the particles, with a minimum value of 0\n         */\n        min: number;\n        /**\n         * Maximum scale of the particles, with a minimum value of 0\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const scale = (Math.random() * (this.max - this.min)) + this.min;\n\n            next.scale.x = next.scale.y = scale;\n\n            next = next.next;\n        }\n    }\n}\n","import { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { SpawnShape, SpawnShapeClass } from './shapes/SpawnShape';\nimport { PolygonalChain } from './shapes/PolygonalChain';\nimport { Rectangle } from './shapes/Rectangle';\nimport { Torus } from './shapes/Torus';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Spawn behavior that places (and optionally rotates) particles according to a\n * specified shape. Additional shapes can be registered with {@link registerShape | SpawnShape.registerShape()}.\n * Additional shapes must implement the {@link SpawnShape} interface, and their class must match the\n * {@link SpawnShapeClass} interface.\n * Shapes included by default are:\n * * {@link Rectangle}\n * * {@link Torus}\n * * {@link PolygonalChain}\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'spawnShape',\n *     config: {\n *          type: 'rect',\n *          data: {\n *              x: 0,\n *              y: 0,\n *              width: 20,\n *              height: 300,\n *          }\n *     }\n * }\n * ```\n */\nexport class ShapeSpawnBehavior implements IEmitterBehavior\n{\n    public static type = 'spawnShape';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    /**\n     * Dictionary of all registered shape classes.\n     */\n    private static shapes: {[key: string]: SpawnShapeClass} = {};\n\n    /**\n     * Registers a shape to be used by the ShapeSpawn behavior.\n     * @param constructor The shape class constructor to use, with a static `type` property to reference it by.\n     * @param typeOverride An optional type override, primarily for registering a shape under multiple names.\n     */\n    public static registerShape(constructor: SpawnShapeClass, typeOverride?: string): void\n    {\n        ShapeSpawnBehavior.shapes[typeOverride || constructor.type] = constructor;\n    }\n\n    order = BehaviorOrder.Spawn;\n    private shape: SpawnShape;\n\n    constructor(config: {\n        /**\n         * Type of the shape to spawn\n         */\n        type: string;\n        /**\n         * Configuration data for the spawn shape.\n         */\n        data: any;\n    })\n    {\n        const ShapeClass = ShapeSpawnBehavior.shapes[config.type];\n\n        if (!ShapeClass)\n        {\n            throw new Error(`No shape found with type '${config.type}'`);\n        }\n        this.shape = new ShapeClass(config.data);\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            this.shape.getRandPos(next);\n            next = next.next;\n        }\n    }\n}\n\nShapeSpawnBehavior.registerShape(PolygonalChain);\nShapeSpawnBehavior.registerShape(Rectangle);\nShapeSpawnBehavior.registerShape(Torus);\nShapeSpawnBehavior.registerShape(Torus, 'circle');\n","import { Texture } from '@pixi/core';\nimport { Particle } from '../Particle';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { GetTextureFromString } from '../ParticleUtils';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Textuure behavior that assigns a single texture to each particle.\n * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'textureSingle',\n *     config: {\n *         texture: Texture.from('myTexId'),\n *     }\n * }\n * ```\n */\nexport class SingleTextureBehavior implements IEmitterBehavior\n{\n    public static type = 'textureSingle';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Normal;\n    private texture: Texture;\n    constructor(config: {\n        /**\n         * Image to use for each particle.\n         */\n        texture: Texture|string;\n    })\n    {\n        this.texture = typeof config.texture === 'string' ? GetTextureFromString(config.texture) : config.texture;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            next.texture = this.texture;\n\n            next = next.next;\n        }\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Particle } from '../Particle';\nimport { rotatePoint, normalize, scaleBy } from '../ParticleUtils';\nimport { PropertyList } from '../PropertyList';\nimport { PropertyNode, ValueList } from '../PropertyNode';\nimport { IEmitterBehavior, BehaviorOrder } from './Behaviors';\nimport { BehaviorEditorConfig } from './editor/Types';\n\n/**\n * A Movement behavior that uses an interpolated or stepped list of values for a particles speed at any given moment.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeed',\n *     config: {\n *          speed: {\n *              list: [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],\n *          },\n *          minMult: 0.8\n *     }\n * }\n * ```\n */\nexport class SpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeed';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private list: PropertyList<number>;\n    private minMult: number;\n    constructor(config: {\n        /**\n         * Speed of the particles in world units/second, with a minimum value of 0\n         */\n        speed: ValueList<number>;\n        /**\n         * A value between minimum speed multipler and 1 is randomly\n         * generated and multiplied with each speed value to generate the actual speed for each particle.\n         */\n        minMult: number;\n    })\n    {\n        this.list = new PropertyList(false);\n        this.list.reset(PropertyNode.createList(config.speed));\n        this.minMult = config.minMult ?? 1;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const mult = (Math.random() * (1 - this.minMult)) + this.minMult;\n\n            next.config.speedMult = mult;\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(this.list.first.value * mult, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(this.list.first.value * mult, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const speed = this.list.interpolate(particle.agePercent) * particle.config.speedMult;\n        const vel = particle.config.velocity;\n\n        normalize(vel);\n        scaleBy(vel, speed);\n        particle.x += vel.x * deltaSec;\n        particle.y += vel.y * deltaSec;\n    }\n}\n\n/**\n * A Movement behavior that uses a randomly picked constant speed throughout a particle's lifetime.\n * Movement direction is controlled by the particle's starting rotation.\n *\n * Example config:\n * ```javascript\n * {\n *     type: 'moveSpeedStatic',\n *     config: {\n *          min: 100,\n *          max: 150\n *     }\n * }\n * ```\n */\nexport class StaticSpeedBehavior implements IEmitterBehavior\n{\n    public static type = 'moveSpeedStatic';\n    public static editorConfig: BehaviorEditorConfig = null;\n\n    public order = BehaviorOrder.Late;\n    private min: number;\n    private max: number;\n    constructor(config: {\n        /**\n         * Minimum speed when initializing the particle.\n         */\n        min: number;\n        /**\n         * Maximum speed when initializing the particle.\n         */\n        max: number;\n    })\n    {\n        this.min = config.min;\n        this.max = config.max;\n    }\n\n    initParticles(first: Particle): void\n    {\n        let next = first;\n\n        while (next)\n        {\n            const speed = (Math.random() * (this.max - this.min)) + this.min;\n\n            if (!next.config.velocity)\n            {\n                next.config.velocity = new Point(speed, 0);\n            }\n            else\n            {\n                (next.config.velocity as Point).set(speed, 0);\n            }\n\n            rotatePoint(next.rotation, next.config.velocity);\n\n            next = next.next;\n        }\n    }\n\n    updateParticle(particle: Particle, deltaSec: number): void\n    {\n        const velocity = particle.config.velocity;\n\n        particle.x += velocity.x * deltaSec;\n        particle.y += velocity.y * deltaSec;\n    }\n}\n","import { Emitter } from './Emitter';\nimport * as behaviors from './behaviors';\n\nEmitter.registerBehavior(behaviors.AccelerationBehavior);\nEmitter.registerBehavior(behaviors.AlphaBehavior);\nEmitter.registerBehavior(behaviors.StaticAlphaBehavior);\nEmitter.registerBehavior(behaviors.RandomAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.SingleAnimatedTextureBehavior);\nEmitter.registerBehavior(behaviors.BlendModeBehavior);\nEmitter.registerBehavior(behaviors.BurstSpawnBehavior);\nEmitter.registerBehavior(behaviors.ColorBehavior);\nEmitter.registerBehavior(behaviors.StaticColorBehavior);\nEmitter.registerBehavior(behaviors.OrderedTextureBehavior);\nEmitter.registerBehavior(behaviors.PathBehavior);\nEmitter.registerBehavior(behaviors.PointSpawnBehavior);\nEmitter.registerBehavior(behaviors.RandomTextureBehavior);\nEmitter.registerBehavior(behaviors.RotationBehavior);\nEmitter.registerBehavior(behaviors.StaticRotationBehavior);\nEmitter.registerBehavior(behaviors.NoRotationBehavior);\nEmitter.registerBehavior(behaviors.ScaleBehavior);\nEmitter.registerBehavior(behaviors.StaticScaleBehavior);\nEmitter.registerBehavior(behaviors.ShapeSpawnBehavior);\nEmitter.registerBehavior(behaviors.SingleTextureBehavior);\nEmitter.registerBehavior(behaviors.SpeedBehavior);\nEmitter.registerBehavior(behaviors.StaticSpeedBehavior);\n\nexport * as behaviors from './behaviors';\nexport * as ParticleUtils from './ParticleUtils';\nexport * from './Particle';\nexport * from './Emitter';\nexport * from './EmitterConfig';\nexport * from './PropertyList';\nexport * from './PropertyNode';\nexport * from './LinkedListContainer';\n","import { Container, DisplayObject } from '@pixi/display';\nimport { Renderer, MaskData } from '@pixi/core';\nimport { Rectangle } from '@pixi/math';\n\n/** Interface for a child of a LinkedListContainer (has the prev/next properties added) */\nexport interface LinkedListChild extends DisplayObject\n{\n    nextChild: LinkedListChild|null;\n    prevChild: LinkedListChild|null;\n}\n\n/**\n * A semi-experimental Container that uses a doubly linked list to manage children instead of an\n * array. This means that adding/removing children often is not the same performance hit that\n * it would to be continually pushing/splicing.\n * However, this is primarily intended to be used for heavy particle usage, and may not handle\n * edge cases well if used as a complete Container replacement.\n */\nexport class LinkedListContainer extends Container\n{\n    private _firstChild: LinkedListChild|null = null;\n    private _lastChild: LinkedListChild|null = null;\n    private _childCount = 0;\n\n    public get firstChild(): LinkedListChild\n    {\n        return this._firstChild;\n    }\n\n    public get lastChild(): LinkedListChild\n    {\n        return this._lastChild;\n    }\n\n    public get childCount(): number\n    {\n        return this._childCount;\n    }\n\n    public addChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                // eslint-disable-next-line prefer-rest-params\n                this.addChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0] as LinkedListChild;\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            // add to list if we have a list\n            if (this._lastChild)\n            {\n                this._lastChild.nextChild = child;\n                child.prevChild = this._lastChild;\n                this._lastChild = child;\n            }\n            // otherwise initialize the list\n            else\n            {\n                this._firstChild = this._lastChild = child;\n            }\n\n            // update child count\n            ++this._childCount;\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange();\n            this.emit('childAdded', child, this, this._childCount);\n            child.emit('added', this);\n        }\n\n        return children[0];\n    }\n\n    public addChildAt<T extends DisplayObject>(child: T, index: number): T\n    {\n        if (index < 0 || index > this._childCount)\n        {\n            throw new Error(`addChildAt: The index ${index} supplied is out of bounds ${this._childCount}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        const c = (child as any) as LinkedListChild;\n\n        // if no children, do basic initialization\n        if (!this._firstChild)\n        {\n            this._firstChild = this._lastChild = c;\n        }\n        // add at beginning (back)\n        else if (index === 0)\n        {\n            this._firstChild.prevChild = c;\n            c.nextChild = this._firstChild;\n            this._firstChild = c;\n        }\n        // add at end (front)\n        else if (index === this._childCount)\n        {\n            this._lastChild.nextChild = c;\n            c.prevChild = this._lastChild;\n            this._lastChild = c;\n        }\n        // otherwise we have to start counting through the children to find the right one\n        // - SLOW, only provided to fully support the possibility of use\n        else\n        {\n            let i = 0;\n            let target = this._firstChild;\n\n            while (i < index)\n            {\n                target = target.nextChild;\n                ++i;\n            }\n            // insert before the target that we found at the specified index\n            target.prevChild.nextChild = c;\n            c.prevChild = target.prevChild;\n            c.nextChild = target;\n            target.prevChild = c;\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container to be rendered below another child.\n     *\n     * @param child The child to add\n     * @param relative - The current child to add the new child relative to.\n     * @return The child that was added.\n     */\n    public addChildBelow<T extends DisplayObject>(child: T, relative: DisplayObject): T\n    {\n        if (relative.parent !== this)\n        {\n            throw new Error(`addChildBelow: The relative target must be a child of this parent`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        // insert before the target that we were given\n        (relative as LinkedListChild).prevChild.nextChild = (child as any as LinkedListChild);\n        (child as any as LinkedListChild).prevChild = (relative as LinkedListChild).prevChild;\n        (child as any as LinkedListChild).nextChild = (relative as LinkedListChild);\n        (relative as LinkedListChild).prevChild = (child as any as LinkedListChild);\n        if (this._firstChild === relative)\n        {\n            this._firstChild = (child as any as LinkedListChild);\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange();\n        this.emit('childAdded', child, this, this._childCount);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container to be rendered above another child.\n     *\n     * @param child The child to add\n     * @param relative - The current child to add the new child relative to.\n     * @return The child that was added.\n     */\n    public addChildAbove<T extends DisplayObject>(child: T, relative: DisplayObject): T\n    {\n        if (relative.parent !== this)\n        {\n            throw new Error(`addChildBelow: The relative target must be a child of this parent`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        // insert after the target that we were given\n        (relative as LinkedListChild).nextChild.prevChild = (child as any as LinkedListChild);\n        (child as any as LinkedListChild).nextChild = (relative as LinkedListChild).nextChild;\n        (child as any as LinkedListChild).prevChild = (relative as LinkedListChild);\n        (relative as LinkedListChild).nextChild = (child as any as LinkedListChild);\n        if (this._lastChild === relative)\n        {\n            this._lastChild = (child as any as LinkedListChild);\n        }\n\n        // update child count\n        ++this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange();\n        this.emit('childAdded', child, this, this._childCount);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    public swapChildren(child: DisplayObject, child2: DisplayObject): void\n    {\n        if (child === child2 || child.parent !== this || child2.parent !== this)\n        {\n            return;\n        }\n\n        const { prevChild, nextChild } = (child as LinkedListChild);\n\n        (child as LinkedListChild).prevChild = (child2 as LinkedListChild).prevChild;\n        (child as LinkedListChild).nextChild = (child2 as LinkedListChild).nextChild;\n        (child2 as LinkedListChild).prevChild = prevChild;\n        (child2 as LinkedListChild).nextChild = nextChild;\n\n        if (this._firstChild === child)\n        {\n            this._firstChild = child2 as LinkedListChild;\n        }\n        else if (this._firstChild === child2)\n        {\n            this._firstChild = child as LinkedListChild;\n        }\n        if (this._lastChild === child)\n        {\n            this._lastChild = child2 as LinkedListChild;\n        }\n        else if (this._lastChild === child2)\n        {\n            this._lastChild = child as LinkedListChild;\n        }\n\n        this.onChildrenChange();\n    }\n\n    public getChildIndex(child: DisplayObject): number\n    {\n        let index = 0;\n        let test = this._firstChild;\n\n        while (test)\n        {\n            if (test === child)\n            {\n                break;\n            }\n            test = test.nextChild;\n            ++index;\n        }\n        if (!test)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    setChildIndex(child: DisplayObject, index: number): void\n    {\n        if (index < 0 || index >= this._childCount)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this._childCount}`);\n        }\n        if (child.parent !== this)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        // remove child\n        if ((child as LinkedListChild).nextChild)\n        {\n            (child as LinkedListChild).nextChild.prevChild = (child as LinkedListChild).prevChild;\n        }\n        if ((child as LinkedListChild).prevChild)\n        {\n            (child as LinkedListChild).prevChild.nextChild = (child as LinkedListChild).nextChild;\n        }\n        if (this._firstChild === (child as LinkedListChild))\n        {\n            this._firstChild = (child as LinkedListChild).nextChild;\n        }\n        if (this._lastChild === (child as LinkedListChild))\n        {\n            this._lastChild = (child as LinkedListChild).prevChild;\n        }\n        (child as LinkedListChild).nextChild = null;\n        (child as LinkedListChild).prevChild = null;\n\n        // do addChildAt\n        if (!this._firstChild)\n        {\n            this._firstChild = this._lastChild = (child as LinkedListChild);\n        }\n        else if (index === 0)\n        {\n            this._firstChild.prevChild = (child as LinkedListChild);\n            (child as LinkedListChild).nextChild = this._firstChild;\n            this._firstChild = (child as LinkedListChild);\n        }\n        else if (index === this._childCount)\n        {\n            this._lastChild.nextChild = (child as LinkedListChild);\n            (child as LinkedListChild).prevChild = this._lastChild;\n            this._lastChild = (child as LinkedListChild);\n        }\n        else\n        {\n            let i = 0;\n            let target = this._firstChild;\n\n            while (i < index)\n            {\n                target = target.nextChild;\n                ++i;\n            }\n            target.prevChild.nextChild = (child as LinkedListChild);\n            (child as LinkedListChild).prevChild = target.prevChild;\n            (child as LinkedListChild).nextChild = target;\n            target.prevChild = (child as LinkedListChild);\n        }\n\n        this.onChildrenChange(index);\n    }\n\n    public removeChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0] as LinkedListChild;\n\n            // bail if not actually our child\n            if (child.parent !== this) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            // swap out child references\n            if (child.nextChild)\n            {\n                child.nextChild.prevChild = child.prevChild;\n            }\n            if (child.prevChild)\n            {\n                child.prevChild.nextChild = child.nextChild;\n            }\n            if (this._firstChild === child)\n            {\n                this._firstChild = child.nextChild;\n            }\n            if (this._lastChild === child)\n            {\n                this._lastChild = child.prevChild;\n            }\n            // clear sibling references\n            child.nextChild = null;\n            child.prevChild = null;\n\n            // update child count\n            --this._childCount;\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange();\n            child.emit('removed', this);\n            this.emit('childRemoved', child, this);\n        }\n\n        return children[0];\n    }\n\n    public getChildAt(index: number): DisplayObject\n    {\n        if (index < 0 || index >= this._childCount)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        if (index === 0)\n        {\n            return this._firstChild;\n        }\n        // add at end (front)\n        else if (index === this._childCount)\n        {\n            return this._lastChild;\n        }\n        // otherwise we have to start counting through the children to find the right one\n        // - SLOW, only provided to fully support the possibility of use\n        let i = 0;\n        let target = this._firstChild;\n\n        while (i < index)\n        {\n            target = target.nextChild;\n            ++i;\n        }\n\n        return target;\n    }\n\n    public removeChildAt(index: number): DisplayObject\n    {\n        const child = this.getChildAt(index) as LinkedListChild;\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        // swap out child references\n        if (child.nextChild)\n        {\n            child.nextChild.prevChild = child.prevChild;\n        }\n        if (child.prevChild)\n        {\n            child.prevChild.nextChild = child.nextChild;\n        }\n        if (this._firstChild === child)\n        {\n            this._firstChild = child.nextChild;\n        }\n        if (this._lastChild === child)\n        {\n            this._lastChild = child.prevChild;\n        }\n        // clear sibling references\n        child.nextChild = null;\n        child.prevChild = null;\n\n        // update child count\n        --this._childCount;\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    public removeChildren(beginIndex = 0, endIndex = this._childCount): DisplayObject[]\n    {\n        const begin = beginIndex;\n        const end = endIndex;\n        const range = end - begin;\n\n        if (range > 0 && range <= end)\n        {\n            const removed: LinkedListChild[] = [];\n            let child = this._firstChild;\n\n            for (let i = 0; i <= end && child; ++i, child = child.nextChild)\n            {\n                if (i >= begin)\n                {\n                    removed.push(child);\n                }\n            }\n\n            // child before removed section\n            const prevChild = removed[0].prevChild;\n            // child after removed section\n            const nextChild = removed[removed.length - 1].nextChild;\n\n            if (!nextChild)\n            {\n                // if we removed the last child, then the new last child is the one before\n                // the removed section\n                this._lastChild = prevChild;\n            }\n            else\n            {\n                // otherwise, stitch the child before the section to the child after\n                nextChild.prevChild = prevChild;\n            }\n            if (!prevChild)\n            {\n                // if we removed the first child, then the new first child is the one after\n                // the removed section\n                this._firstChild = nextChild;\n            }\n            else\n            {\n                // otherwise stich the child after the section to the one before\n                prevChild.nextChild = nextChild;\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                // clear parenting and sibling references for all removed children\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n                removed[i].nextChild = null;\n                removed[i].prevChild = null;\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this._childCount === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering.\n     * Copied from and overrides PixiJS v5 method (v4 method is identical)\n     */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     * Copied from and overrides PixiJS v5 method (v4 method is identical)\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = ((child._mask as MaskData).maskObject || child._mask) as Container;\n\n                maskObject.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._bounds.updateID = this._boundsID;\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object. Copied from and overrides PixiJS v5 method\n     */\n    public getLocalBounds(rect?: Rectangle, skipChildrenUpdate = false): Rectangle\n    {\n        // skip Container's getLocalBounds, go directly to DisplayObject\n        const result = DisplayObject.prototype.getLocalBounds.call(this, rect);\n\n        if (!skipChildrenUpdate)\n        {\n            let child;\n            let next;\n\n            for (child = this._firstChild; child; child = next)\n            {\n                next = child.nextChild;\n\n                if (child.visible)\n                {\n                    child.updateTransform();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer. Copied from and overrides PixiJS v5 method\n     */\n    render(renderer: Renderer): void\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvanced(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            let child;\n            let next;\n\n            // simple render children!\n            for (child = this._firstChild; child; child = next)\n            {\n                next = child.nextChild;\n                child.render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS v5 method\n     */\n    protected renderAdvanced(renderer: Renderer): void\n    {\n        renderer.batch.flush();\n\n        const filters = this.filters;\n        const mask = this._mask;\n\n        // _enabledFilters note: As of development, _enabledFilters is not documented in pixi.js\n        // types but is in code of current release (5.2.4).\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filter.push(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._render(renderer);\n\n        let child;\n        let next;\n\n        // now loop through the children and make sure they get rendered\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n            child.render(renderer);\n        }\n\n        renderer.batch.flush();\n\n        if (mask)\n        {\n            renderer.mask.pop(this);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * Renders the object using the Canvas renderer. Copied from and overrides PixiJS Canvas mixin in V5 and V6.\n     */\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    renderCanvas(renderer: any): void\n    {\n        // if not visible or the alpha is 0 then no need to render this\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.pushMask(this._mask);\n        }\n\n        (this as any)._renderCanvas(renderer);\n\n        let child;\n        let next;\n\n        for (child = this._firstChild; child; child = next)\n        {\n            next = child.nextChild;\n            (child as any).renderCanvas(renderer);\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.popMask(renderer);\n        }\n    }\n}\n","/* eslint-disable no-lonely-if */\nimport { EaseSegment, SimpleEase } from './ParticleUtils';\nimport { ValueList } from './PropertyNode';\nimport { IPointData } from '@pixi/math';\n\n/**\n * Full Emitter configuration for initializing an Emitter instance.\n */\nexport interface EmitterConfigV3\n{\n    /**\n     * Random number configuration for picking the lifetime for each particle..\n     */\n    lifetime: RandNumber;\n    /**\n     * Easing to be applied to all interpolated or stepped values across the particle lifetime.\n     */\n    ease?: SimpleEase | EaseSegment[];\n    /**\n     * How many particles to spawn at once, each time that it is determined that particles should be spawned.\n     * If omitted, only one particle will spawn at a time.\n     */\n    particlesPerWave?: number;\n    /**\n     * How often to spawn particles. This is a value in seconds, so a value of 0.5 would be twice a second.\n     */\n    frequency: number;\n    /**\n     * Defines a chance to not spawn particles. Values lower than 1 mean particles may not be spawned each time.\n     * If omitted, particles will always spawn.\n     */\n    spawnChance?: number;\n    /**\n     * How long to run the Emitter before it stops spawning particles. If omitted, runs forever (or until told to stop\n     * manually).\n     */\n    emitterLifetime?: number;\n    /**\n     * Maximum number of particles that can be alive at any given time for this emitter.\n     */\n    maxParticles?: number;\n    /**\n     * If newly spawned particles should be added to the back of the parent container (to make them less conspicuous\n     * as they pop in). If omitted, particles will be added to the top of the container.\n     */\n    addAtBack?: boolean;\n    /**\n     * Default position to spawn particles from inside the parent container.\n     */\n    pos: { x: number; y: number };\n    /**\n     * If the emitter should start out emitting particles. If omitted, it will be treated as `true` and will emit particles\n     * immediately.\n     */\n    emit?: boolean;\n    /**\n     * If the Emitter should hook into PixiJS's shared ticker. If this is false or emitted, you will be responsible for\n     * connecting it to update ticks.\n     */\n    autoUpdate?: boolean;\n\n    /**\n     * The list of behaviors to apply to this emitter. See the behaviors namespace for\n     * a list of built in behaviors. Custom behaviors may be registered with {@link Emitter.registerBehavior}.\n     */\n    behaviors: BehaviorEntry[];\n}\n\n/**\n * See {@link EmitterConfigV3.behaviors}\n */\nexport interface BehaviorEntry\n{\n    /**\n     * The behavior type, as defined as the static `type` property of a behavior class.\n     */\n    type: string;\n    /**\n     * Configuration data specific to that behavior.\n     */\n    config: any;\n}\n\n/**\n * Configuration for how to pick a random number (inclusive).\n */\nexport interface RandNumber\n{\n    /**\n     * Maximum pickable value.\n     */\n    max: number;\n    /**\n     * Minimum pickable value.\n     */\n    min: number;\n}\n\n/**\n * Converts emitter configuration from pre-5.0.0 library values into the current version.\n *\n * Example usage:\n * ```javascript\n * const emitter = new Emitter(myContainer, upgradeConfig(myOldConfig, [myTexture, myOtherTexture]));\n * ```\n * @param config The old emitter config to upgrade.\n * @param art The old art values as would have been passed into the Emitter constructor or `Emitter.init()`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function upgradeConfig(config: EmitterConfigV2|EmitterConfigV1, art: any): EmitterConfigV3\n{\n    // just ensure we aren't given any V3 config data\n    if ('behaviors' in config)\n    {\n        return config;\n    }\n\n    const out: EmitterConfigV3 = {\n        lifetime: config.lifetime,\n        ease: config.ease,\n        particlesPerWave: config.particlesPerWave,\n        frequency: config.frequency,\n        spawnChance: config.spawnChance,\n        emitterLifetime: config.emitterLifetime,\n        maxParticles: config.maxParticles,\n        addAtBack: config.addAtBack,\n        pos: config.pos,\n        emit: config.emit,\n        autoUpdate: config.autoUpdate,\n        behaviors: [],\n    };\n\n    // set up the alpha\n    if (config.alpha)\n    {\n        if ('start' in config.alpha)\n        {\n            if (config.alpha.start === config.alpha.end)\n            {\n                if (config.alpha.start !== 1)\n                {\n                    out.behaviors.push({\n                        type: 'alphaStatic',\n                        config: { alpha: config.alpha.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.alpha.start },\n                        { time: 1, value: config.alpha.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'alpha',\n                    config: { alpha: list },\n                });\n            }\n        }\n        else if (config.alpha.list.length === 1)\n        {\n            if (config.alpha.list[0].value !== 1)\n            {\n                out.behaviors.push({\n                    type: 'alphaStatic',\n                    config: { alpha: config.alpha.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'alpha',\n                config: { alpha: config.alpha },\n            });\n        }\n    }\n\n    // acceleration movement\n    if (config.acceleration && (config.acceleration.x || config.acceleration.y))\n    {\n        let minStart: number;\n        let maxStart: number;\n\n        if ('start' in config.speed)\n        {\n            minStart = config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.start;\n        }\n        else\n        {\n            minStart = config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n            maxStart = config.speed.list[0].value;\n        }\n\n        out.behaviors.push({\n            type: 'moveAcceleration',\n            config: {\n                accel: config.acceleration,\n                minStart,\n                maxStart,\n                rotate: !config.noRotation,\n                maxSpeed: config.maxSpeed,\n            },\n        });\n    }\n    // path movement\n    else if (config.extraData?.path)\n    {\n        let list: ValueList<number>;\n        let mult: number;\n\n        if ('start' in config.speed)\n        {\n            mult = config.speed.minimumSpeedMultiplier ?? 1;\n            if (config.speed.start === config.speed.end)\n            {\n                list = {\n                    list: [{ time: 0, value: config.speed.start }],\n                };\n            }\n            else\n            {\n                list = {\n                    list: [\n                        { time: 0, value: config.speed.start },\n                        { time: 1, value: config.speed.end },\n                    ],\n                };\n            }\n        }\n        else\n        {\n            list = config.speed;\n            mult = ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1);\n        }\n\n        out.behaviors.push({\n            type: 'movePath',\n            config: {\n                path: config.extraData.path,\n                speed: list,\n                minMult: mult,\n            },\n        });\n    }\n    // normal speed movement\n    else\n    {\n        if ('start' in config.speed)\n        {\n            if (config.speed.start === config.speed.end)\n            {\n                out.behaviors.push({\n                    type: 'moveSpeedStatic',\n                    config: {\n                        min: config.speed.start * (config.speed.minimumSpeedMultiplier ?? 1),\n                        max: config.speed.start,\n                    },\n                });\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.speed.start },\n                        { time: 1, value: config.speed.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'moveSpeed',\n                    config: { speed: list, minMult: config.speed.minimumSpeedMultiplier },\n                });\n            }\n        }\n        else if (config.speed.list.length === 1)\n        {\n            out.behaviors.push({\n                type: 'moveSpeedStatic',\n                config: {\n                    min: config.speed.list[0].value * ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1),\n                    max: config.speed.list[0].value,\n                },\n            });\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'moveSpeed',\n                config: { speed: config.speed, minMult: ((config as EmitterConfigV2).minimumSpeedMultiplier ?? 1) },\n            });\n        }\n    }\n\n    // scale\n    if (config.scale)\n    {\n        if ('start' in config.scale)\n        {\n            const mult = config.scale.minimumScaleMultiplier ?? 1;\n\n            if (config.scale.start === config.scale.end)\n            {\n                out.behaviors.push({\n                    type: 'scaleStatic',\n                    config: {\n                        min: config.scale.start * mult,\n                        max: config.scale.start,\n                    },\n                });\n            }\n            else\n            {\n                const list: ValueList<number> = {\n                    list: [\n                        { time: 0, value: config.scale.start },\n                        { time: 1, value: config.scale.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'scale',\n                    config: { scale: list, minMult: mult },\n                });\n            }\n        }\n        else if (config.scale.list.length === 1)\n        {\n            const mult = (config as EmitterConfigV2).minimumScaleMultiplier ?? 1;\n            const scale = config.scale.list[0].value;\n\n            out.behaviors.push({\n                type: 'scaleStatic',\n                config: { min: scale * mult, max: scale },\n            });\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'scale',\n                config: { scale: config.scale, minMult: (config as EmitterConfigV2).minimumScaleMultiplier ?? 1 },\n            });\n        }\n    }\n\n    // color\n    if (config.color)\n    {\n        if ('start' in config.color)\n        {\n            if (config.color.start === config.color.end)\n            {\n                if (config.color.start !== 'ffffff')\n                {\n                    out.behaviors.push({\n                        type: 'colorStatic',\n                        config: { color: config.color.start },\n                    });\n                }\n            }\n            else\n            {\n                const list: ValueList<string> = {\n                    list: [\n                        { time: 0, value: config.color.start },\n                        { time: 1, value: config.color.end },\n                    ],\n                };\n\n                out.behaviors.push({\n                    type: 'color',\n                    config: { color: list },\n                });\n            }\n        }\n        else if (config.color.list.length === 1)\n        {\n            if (config.color.list[0].value !== 'ffffff')\n            {\n                out.behaviors.push({\n                    type: 'colorStatic',\n                    config: { color: config.color.list[0].value },\n                });\n            }\n        }\n        else\n        {\n            out.behaviors.push({\n                type: 'color',\n                config: { color: config.color },\n            });\n        }\n    }\n\n    // rotation\n    if (config.rotationAcceleration || config.rotationSpeed?.min || config.rotationSpeed.max)\n    {\n        out.behaviors.push({\n            type: 'rotation',\n            config: {\n                accel: config.rotationAcceleration || 0,\n                minSpeed: config.rotationSpeed?.min || 0,\n                maxSpeed: config.rotationSpeed?.max || 0,\n                minStart: config.startRotation?.min || 0,\n                maxStart: config.startRotation?.max || 0,\n            },\n        });\n    }\n    else if (config.startRotation?.min || config.startRotation?.max)\n    {\n        out.behaviors.push({\n            type: 'rotationStatic',\n            config: {\n                min: config.startRotation?.min || 0,\n                max: config.startRotation?.max || 0,\n            },\n        });\n    }\n    if (config.noRotation)\n    {\n        out.behaviors.push({\n            type: 'noRotation',\n            config: {},\n        });\n    }\n\n    // blend mode\n    if (config.blendMode && config.blendMode !== 'normal')\n    {\n        out.behaviors.push({\n            type: 'blendMode',\n            config: {\n                blendMode: config.blendMode,\n            },\n        });\n    }\n\n    // animated\n    if (Array.isArray(art) && typeof art[0] !== 'string' && 'framerate' in art[0])\n    {\n        for (let i = 0; i < art.length; ++i)\n        {\n            if (art[i].framerate === 'matchLife')\n            {\n                art[i].framerate = -1;\n            }\n        }\n        out.behaviors.push({\n            type: 'animatedRandom',\n            config: {\n                anims: art,\n            },\n        });\n    }\n    else if (typeof art !== 'string' && 'framerate' in art)\n    {\n        if (art.framerate === 'matchLife')\n        {\n            art.framerate = -1;\n        }\n        out.behaviors.push({\n            type: 'animatedSingle',\n            config: {\n                anim: art,\n            },\n        });\n    }\n    // ordered art\n    else if (config.orderedArt && Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureOrdered',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // random texture\n    else if (Array.isArray(art))\n    {\n        out.behaviors.push({\n            type: 'textureRandom',\n            config: {\n                textures: art,\n            },\n        });\n    }\n    // single texture\n    else\n    {\n        out.behaviors.push({\n            type: 'textureSingle',\n            config: {\n                texture: art,\n            },\n        });\n    }\n\n    // spawn burst\n    if (config.spawnType === 'burst')\n    {\n        out.behaviors.push({\n            type: 'spawnBurst',\n            config: {\n                start: config.angleStart || 0,\n                spacing: config.particleSpacing,\n                // older formats bursted from a single point\n                distance: 0,\n            },\n        });\n    }\n    // spawn point\n    else if (config.spawnType === 'point')\n    {\n        out.behaviors.push({\n            type: 'spawnPoint',\n            config: {},\n        });\n    }\n    // spawn shape\n    else\n    {\n        let shape: any;\n\n        if (config.spawnType === 'ring')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: config.spawnCircle.minR,\n                    affectRotation: true,\n                },\n            };\n        }\n        else if (config.spawnType === 'circle')\n        {\n            shape = {\n                type: 'torus',\n                data: {\n                    x: config.spawnCircle.x,\n                    y: config.spawnCircle.y,\n                    radius: config.spawnCircle.r,\n                    innerRadius: 0,\n                    affectRotation: false,\n                },\n            };\n        }\n        else if (config.spawnType === 'rect')\n        {\n            shape = {\n                type: 'rect',\n                data: config.spawnRect,\n            };\n        }\n        else if (config.spawnType === 'polygonalChain')\n        {\n            shape = {\n                type: 'polygonalChain',\n                data: config.spawnPolygon,\n            };\n        }\n        out.behaviors.push({\n            type: 'spawnShape',\n            config: shape,\n        });\n    }\n\n    return out;\n}\n\n/**\n * The obsolete emitter configuration format from version 3.0.0 of the library.\n * This type information is kept to make it easy to upgrade, but otherwise\n * configuration should be made as {@link EmitterConfigV3}.\n */\nexport interface EmitterConfigV2 {\n    alpha?: ValueList<number>;\n    speed?: ValueList<number>;\n    minimumSpeedMultiplier?: number;\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: ValueList<number>;\n    minimumScaleMultiplier?: number;\n    color?: ValueList<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: IPointData[] | IPointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n\nexport interface BasicTweenable<T> {\n    start: T;\n    end: T;\n}\n\n/**\n * The obsolete emitter configuration format of the initial library release.\n * This type information is kept to maintain compatibility with the older particle tool, but otherwise\n * configuration should be made as {@link EmitterConfigV3}.\n */\nexport interface EmitterConfigV1 {\n    alpha?: BasicTweenable<number>;\n    speed?: BasicTweenable<number> & {minimumSpeedMultiplier?: number};\n    maxSpeed?: number;\n    acceleration?: {x: number; y: number};\n    scale?: BasicTweenable<number> & {minimumScaleMultiplier?: number};\n    color?: BasicTweenable<string>;\n    startRotation?: RandNumber;\n    noRotation?: boolean;\n    rotationSpeed?: RandNumber;\n    rotationAcceleration?: number;\n    lifetime: RandNumber;\n    blendMode?: string;\n    ease?: SimpleEase | EaseSegment[];\n    extraData?: any;\n    particlesPerWave?: number;\n    /**\n     * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\n     * tends to be too strict for random object creation.\n     */\n    spawnType?: string;\n    spawnRect?: {x: number; y: number; w: number; h: number};\n    spawnCircle?: {x: number; y: number; r: number; minR?: number};\n    particleSpacing?: number;\n    angleStart?: number;\n    spawnPolygon?: IPointData[] | IPointData[][];\n    frequency: number;\n    spawnChance?: number;\n    emitterLifetime?: number;\n    maxParticles?: number;\n    addAtBack?: boolean;\n    pos: {x: number; y: number};\n    emit?: boolean;\n    autoUpdate?: boolean;\n    orderedArt?: boolean;\n}\n"]}